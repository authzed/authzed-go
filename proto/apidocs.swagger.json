{
  "swagger": "2.0",
  "info": {
    "title": "Authzed",
    "version": "1.0",
    "contact": {
      "name": "Authzed, Inc.",
      "url": "https://github.com/authzed/api",
      "email": "support@authzed.com"
    },
    "license": {
      "name": "Apache 2.0 License",
      "url": "https://github.com/authzed/api/blob/main/LICENSE"
    }
  },
  "tags": [
    {
      "name": "DeveloperService"
    },
    {
      "name": "PermissionsService"
    },
    {
      "name": "ExperimentalService"
    },
    {
      "name": "SchemaService"
    },
    {
      "name": "WatchService"
    },
    {
      "name": "SchemaService"
    },
    {
      "name": "WatchResourcesService"
    }
  ],
  "schemes": [
    "http",
    "https",
    "wss"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/experimental/permissions/bulkcheckpermission": {
      "post": {
        "operationId": "ExperimentalService_BulkCheckPermission",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1BulkCheckPermissionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1BulkCheckPermissionRequest"
            }
          }
        ],
        "tags": [
          "ExperimentalService"
        ]
      }
    },
    "/v1/experimental/permissions/streamingbulkcheckpermission": {
      "post": {
        "operationId": "ExperimentalService_StreamingBulkCheckPermission",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1StreamingBulkCheckPermissionResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1StreamingBulkCheckPermissionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1StreamingBulkCheckPermissionRequest"
            }
          }
        ],
        "tags": [
          "ExperimentalService"
        ]
      }
    },
    "/v1/experimental/relationships/bulkexport": {
      "post": {
        "summary": "BulkExportRelationships is the fastest path available to exporting\nrelationships from the server. It is resumable, and will return results\nin an order determined by the server.",
        "operationId": "ExperimentalService_BulkExportRelationships",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1BulkExportRelationshipsResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1BulkExportRelationshipsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "BulkExportRelationshipsRequest represents a resumable request for\nall relationships from the server.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1BulkExportRelationshipsRequest"
            }
          }
        ],
        "tags": [
          "ExperimentalService"
        ]
      }
    },
    "/v1/experimental/relationships/bulkimport": {
      "post": {
        "summary": "BulkImportRelationships is a faster path to writing a large number of\nrelationships at once. It is both batched and streaming. For maximum\nperformance, the caller should attempt to write relationships in as close\nto relationship sort order as possible: (resource.object_type,\nresource.object_id, relation, subject.object.object_type,\nsubject.object.object_id, subject.optional_relation)",
        "description": "EXPERIMENTAL\nhttps://github.com/authzed/spicedb/issues/1303",
        "operationId": "ExperimentalService_BulkImportRelationships",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1BulkImportRelationshipsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "BulkImportRelationshipsRequest represents one batch of the streaming\nBulkImportRelationships API. The maximum size is only limited by the backing\ndatastore, and optimal size should be determined by the calling client\nexperimentally. (streaming inputs)",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1BulkImportRelationshipsRequest"
            }
          }
        ],
        "tags": [
          "ExperimentalService"
        ]
      }
    },
    "/v1/permissions/check": {
      "post": {
        "summary": "CheckPermission determines for a given resource whether a subject computes\nto having a permission or is a direct member of a particular relation.",
        "operationId": "PermissionsService_CheckPermission",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CheckPermissionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "CheckPermissionRequest issues a check on whether a subject has a permission\nor is a member of a relation, on a specific resource.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CheckPermissionRequest"
            }
          }
        ],
        "tags": [
          "PermissionsService"
        ]
      }
    },
    "/v1/permissions/expand": {
      "post": {
        "summary": "ExpandPermissionTree reveals the graph structure for a resource's\npermission or relation. This RPC does not recurse infinitely deep and may\nrequire multiple calls to fully unnest a deeply nested graph.",
        "operationId": "PermissionsService_ExpandPermissionTree",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ExpandPermissionTreeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "ExpandPermissionTreeRequest returns a tree representing the expansion of all\nrelationships found accessible from a permission or relation on a particular\nresource.\n\nExpandPermissionTreeRequest is typically used to determine the full set of\nsubjects with a permission, along with the relationships that grant said\naccess.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ExpandPermissionTreeRequest"
            }
          }
        ],
        "tags": [
          "PermissionsService"
        ]
      }
    },
    "/v1/permissions/resources": {
      "post": {
        "summary": "LookupResources returns all the resources of a given type that a subject\ncan access whether via a computed permission or relation membership.",
        "operationId": "PermissionsService_LookupResources",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1LookupResourcesResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1LookupResourcesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "LookupResourcesRequest performs a lookup of all resources of a particular\nkind on which the subject has the specified permission or the relation in\nwhich the subject exists, streaming back the IDs of those resources.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1LookupResourcesRequest"
            }
          }
        ],
        "tags": [
          "PermissionsService"
        ]
      }
    },
    "/v1/permissions/subjects": {
      "post": {
        "summary": "LookupSubjects returns all the subjects of a given type that\nhave access whether via a computed permission or relation membership.",
        "operationId": "PermissionsService_LookupSubjects",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1LookupSubjectsResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1LookupSubjectsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "LookupSubjectsRequest performs a lookup of all subjects of a particular\nkind for which the subject has the specified permission or the relation in\nwhich the subject exists, streaming back the IDs of those subjects.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1LookupSubjectsRequest"
            }
          }
        ],
        "tags": [
          "PermissionsService"
        ]
      }
    },
    "/v1/relationships/delete": {
      "post": {
        "summary": "DeleteRelationships atomically bulk deletes all relationships matching the\nprovided filter. If no relationships match, none will be deleted and the\noperation will succeed. An optional set of preconditions can be provided that must\nbe satisfied for the operation to commit.",
        "operationId": "PermissionsService_DeleteRelationships",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteRelationshipsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "DeleteRelationshipsRequest specifies which Relationships should be deleted,\nrequesting the delete of *ALL* relationships that match the specified\nfilters. If the optional_preconditions parameter is included, all of the\nspecified preconditions must also be satisfied before the delete will be\nexecuted.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1DeleteRelationshipsRequest"
            }
          }
        ],
        "tags": [
          "PermissionsService"
        ]
      }
    },
    "/v1/relationships/read": {
      "post": {
        "summary": "ReadRelationships reads a set of the relationships matching one or more\nfilters.",
        "operationId": "PermissionsService_ReadRelationships",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1ReadRelationshipsResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1ReadRelationshipsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "ReadRelationshipsRequest specifies one or more filters used to read matching\nrelationships within the system.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ReadRelationshipsRequest"
            }
          }
        ],
        "tags": [
          "PermissionsService"
        ]
      }
    },
    "/v1/relationships/write": {
      "post": {
        "summary": "WriteRelationships atomically writes and/or deletes a set of specified\nrelationships. An optional set of preconditions can be provided that must\nbe satisfied for the operation to commit.",
        "operationId": "PermissionsService_WriteRelationships",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1WriteRelationshipsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "WriteRelationshipsRequest contains a list of Relationship mutations that\nshould be applied to the service. If the optional_preconditions parameter\nis included, all of the specified preconditions must also be satisfied before\nthe write will be committed.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1WriteRelationshipsRequest"
            }
          }
        ],
        "tags": [
          "PermissionsService"
        ]
      }
    },
    "/v1/schema/read": {
      "post": {
        "summary": "Read returns the current Object Definitions for a Permissions System.",
        "description": "Errors include:\n- INVALID_ARGUMENT: a provided value has failed to semantically validate\n- NOT_FOUND: no schema has been defined",
        "operationId": "SchemaService_ReadSchema",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiv1ReadSchemaResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "ReadSchemaRequest returns the schema from the database.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/apiv1ReadSchemaRequest"
            }
          }
        ],
        "tags": [
          "SchemaService"
        ]
      }
    },
    "/v1/schema/write": {
      "post": {
        "summary": "Write overwrites the current Object Definitions for a Permissions System.",
        "operationId": "SchemaService_WriteSchema",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiv1WriteSchemaResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "WriteSchemaRequest is the required data used to \"upsert\" the Schema of a\nPermissions System.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/apiv1WriteSchemaRequest"
            }
          }
        ],
        "tags": [
          "SchemaService"
        ]
      }
    },
    "/v1/watch": {
      "post": {
        "operationId": "WatchService_Watch",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1WatchResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1WatchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "WatchRequest specifies the object definitions for which we want to start\nwatching mutations, and an optional start snapshot for when to start\nwatching.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1WatchRequest"
            }
          }
        ],
        "tags": [
          "WatchService"
        ]
      }
    },
    "/v1alpha1/lookupwatch": {
      "post": {
        "summary": "WatchResources initiates a watch for permission changes for the provided\n(resource type, permission, subject) pair.",
        "operationId": "WatchResourcesService_WatchResources",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1alpha1WatchResourcesResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1alpha1WatchResourcesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "WatchResourcesRequest starts a watch for specific permission updates\nfor the given resource and subject types.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1WatchResourcesRequest"
            }
          }
        ],
        "tags": [
          "WatchResourcesService"
        ]
      }
    }
  },
  "definitions": {
    "DeleteRelationshipsResponseDeletionProgress": {
      "type": "string",
      "enum": [
        "DELETION_PROGRESS_UNSPECIFIED",
        "DELETION_PROGRESS_COMPLETE",
        "DELETION_PROGRESS_PARTIAL"
      ],
      "default": "DELETION_PROGRESS_UNSPECIFIED",
      "description": " - DELETION_PROGRESS_COMPLETE: DELETION_PROGRESS_COMPLETE indicates that all remaining relationships matching the filter\nwere deleted. Will be returned even if no relationships were deleted.\n - DELETION_PROGRESS_PARTIAL: DELETION_PROGRESS_PARTIAL indicates that a subset of the relationships matching the filter\nwere deleted. Only returned if optional_allow_partial_deletions was true, an optional_limit was\nspecified, and there existed more relationships matching the filter than optional_limit would allow.\nOnce all remaining relationships have been deleted, DELETION_PROGRESS_COMPLETE will be returned."
    },
    "DeveloperErrorErrorKind": {
      "type": "string",
      "enum": [
        "UNKNOWN_KIND",
        "PARSE_ERROR",
        "SCHEMA_ISSUE",
        "DUPLICATE_RELATIONSHIP",
        "MISSING_EXPECTED_RELATIONSHIP",
        "EXTRA_RELATIONSHIP_FOUND",
        "UNKNOWN_OBJECT_TYPE",
        "UNKNOWN_RELATION",
        "MAXIMUM_RECURSION",
        "ASSERTION_FAILED"
      ],
      "default": "UNKNOWN_KIND"
    },
    "DeveloperErrorSource": {
      "type": "string",
      "enum": [
        "UNKNOWN_SOURCE",
        "SCHEMA",
        "RELATIONSHIP",
        "VALIDATION_YAML",
        "CHECK_WATCH",
        "ASSERTION"
      ],
      "default": "UNKNOWN_SOURCE"
    },
    "LookupShareResponseLookupStatus": {
      "type": "string",
      "enum": [
        "UNKNOWN_REFERENCE",
        "FAILED_TO_LOOKUP",
        "VALID_REFERENCE",
        "UPGRADED_REFERENCE"
      ],
      "default": "UNKNOWN_REFERENCE"
    },
    "LookupSubjectsRequestWildcardOption": {
      "type": "string",
      "enum": [
        "WILDCARD_OPTION_UNSPECIFIED",
        "WILDCARD_OPTION_INCLUDE_WILDCARDS",
        "WILDCARD_OPTION_EXCLUDE_WILDCARDS"
      ],
      "default": "WILDCARD_OPTION_UNSPECIFIED"
    },
    "SubjectFilterRelationFilter": {
      "type": "object",
      "properties": {
        "relation": {
          "type": "string"
        }
      }
    },
    "apiv1ReadSchemaRequest": {
      "type": "object",
      "description": "ReadSchemaRequest returns the schema from the database."
    },
    "apiv1ReadSchemaResponse": {
      "type": "object",
      "properties": {
        "schemaText": {
          "type": "string",
          "title": "schema_text is the textual form of the current schema in the system"
        },
        "readAt": {
          "$ref": "#/definitions/v1ZedToken",
          "description": "read_at is the ZedToken at which the schema was read."
        }
      },
      "description": "ReadSchemaResponse is the resulting data after having read the Object\nDefinitions from a Schema."
    },
    "apiv1WriteSchemaRequest": {
      "type": "object",
      "properties": {
        "schema": {
          "type": "string",
          "description": "The Schema containing one or more Object Definitions that will be written\nto the Permissions System.\n\n256KiB"
        }
      },
      "description": "WriteSchemaRequest is the required data used to \"upsert\" the Schema of a\nPermissions System."
    },
    "apiv1WriteSchemaResponse": {
      "type": "object",
      "properties": {
        "writtenAt": {
          "$ref": "#/definitions/v1ZedToken",
          "description": "written_at is the ZedToken at which the schema was written."
        }
      },
      "description": "WriteSchemaResponse is the resulting data after having written a Schema to\na Permissions System."
    },
    "apiv1alpha1ReadSchemaResponse": {
      "type": "object",
      "properties": {
        "objectDefinitions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The Object Definitions that were requested."
        },
        "computedDefinitionsRevision": {
          "type": "string",
          "description": "The computed revision of the returned object definitions."
        }
      },
      "description": "ReadSchemaResponse is the resulting data after having read the Object\nDefinitions from a Schema."
    },
    "apiv1alpha1WriteSchemaResponse": {
      "type": "object",
      "properties": {
        "objectDefinitionsNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The names of the Object Definitions that were written."
        },
        "computedDefinitionsRevision": {
          "type": "string",
          "description": "The computed revision of the written object definitions."
        }
      },
      "description": "WriteSchemaResponse is the resulting data after having written a Schema to\na Permissions System."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protobufNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\n The JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code]."
        },
        "message": {
          "type": "string",
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\n[google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client."
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          },
          "description": "A list of messages that carry the error details.  There is a common set of\nmessage types for APIs to use."
        }
      },
      "description": "The `Status` type defines a logical error model that is suitable for\ndifferent programming environments, including REST APIs and RPC APIs. It is\nused by [gRPC](https://github.com/grpc). Each `Status` message contains\nthree pieces of data: error code, error message, and error details.\n\nYou can find out more about this error model and how to work with it in the\n[API Design Guide](https://cloud.google.com/apis/design/errors)."
    },
    "v0DeveloperError": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "line": {
          "type": "integer",
          "format": "int64"
        },
        "column": {
          "type": "integer",
          "format": "int64"
        },
        "source": {
          "$ref": "#/definitions/DeveloperErrorSource"
        },
        "kind": {
          "$ref": "#/definitions/DeveloperErrorErrorKind"
        },
        "path": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "context": {
          "type": "string",
          "description": "context holds the context for the error. For schema issues, this will be the\nname of the object type. For relationship issues, the full relationship string."
        }
      }
    },
    "v0EditCheckResponse": {
      "type": "object",
      "properties": {
        "requestErrors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v0DeveloperError"
          }
        },
        "checkResults": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v0EditCheckResult"
          }
        }
      }
    },
    "v0EditCheckResult": {
      "type": "object",
      "properties": {
        "relationship": {
          "$ref": "#/definitions/v0RelationTuple"
        },
        "isMember": {
          "type": "boolean"
        },
        "error": {
          "$ref": "#/definitions/v0DeveloperError"
        }
      }
    },
    "v0FormatSchemaResponse": {
      "type": "object",
      "properties": {
        "error": {
          "$ref": "#/definitions/v0DeveloperError"
        },
        "formattedSchema": {
          "type": "string"
        }
      }
    },
    "v0LookupShareResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/LookupShareResponseLookupStatus"
        },
        "schema": {
          "type": "string"
        },
        "relationshipsYaml": {
          "type": "string"
        },
        "validationYaml": {
          "type": "string"
        },
        "assertionsYaml": {
          "type": "string"
        }
      }
    },
    "v0ObjectAndRelation": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "objectId": {
          "type": "string"
        },
        "relation": {
          "type": "string"
        }
      }
    },
    "v0RelationTuple": {
      "type": "object",
      "properties": {
        "objectAndRelation": {
          "$ref": "#/definitions/v0ObjectAndRelation",
          "description": "Each tupleset specifies keys of a set of relation tuples. The set can\ninclude a single tuple key, or all tuples with a given object ID or\nuserset in a namespace, optionally constrained by a relation name.\n\nexamples:\ndoc:readme#viewer@group:eng#member (fully specified)\ndoc:*#*#group:eng#member (all tuples that this userset relates to)\ndoc:12345#*#* (all tuples with a direct relationship to a document)\ndoc:12345#writer#* (all tuples with direct write relationship with the\ndocument) doc:#writer#group:eng#member (all tuples that eng group has write\nrelationship)"
        },
        "user": {
          "$ref": "#/definitions/v0User"
        }
      }
    },
    "v0RequestContext": {
      "type": "object",
      "properties": {
        "schema": {
          "type": "string"
        },
        "relationships": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v0RelationTuple"
          }
        }
      }
    },
    "v0ShareResponse": {
      "type": "object",
      "properties": {
        "shareReference": {
          "type": "string"
        }
      }
    },
    "v0UpgradeSchemaResponse": {
      "type": "object",
      "properties": {
        "error": {
          "$ref": "#/definitions/v0DeveloperError"
        },
        "upgradedSchema": {
          "type": "string"
        }
      }
    },
    "v0User": {
      "type": "object",
      "properties": {
        "userset": {
          "$ref": "#/definitions/v0ObjectAndRelation"
        }
      }
    },
    "v0ValidateResponse": {
      "type": "object",
      "properties": {
        "requestErrors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v0DeveloperError"
          }
        },
        "validationErrors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v0DeveloperError"
          }
        },
        "updatedValidationYaml": {
          "type": "string"
        }
      }
    },
    "v1AlgebraicSubjectSet": {
      "type": "object",
      "properties": {
        "operation": {
          "$ref": "#/definitions/v1AlgebraicSubjectSetOperation"
        },
        "children": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PermissionRelationshipTree"
          }
        }
      },
      "description": "AlgebraicSubjectSet is a subject set which is computed based on applying the\nspecified operation to the operands according to the algebra of sets.\n\nUNION is a logical set containing the subject members from all operands.\n\nINTERSECTION is a logical set containing only the subject members which are\npresent in all operands.\n\nEXCLUSION is a logical set containing only the subject members which are\npresent in the first operand, and none of the other operands."
    },
    "v1AlgebraicSubjectSetOperation": {
      "type": "string",
      "enum": [
        "OPERATION_UNSPECIFIED",
        "OPERATION_UNION",
        "OPERATION_INTERSECTION",
        "OPERATION_EXCLUSION"
      ],
      "default": "OPERATION_UNSPECIFIED"
    },
    "v1BulkCheckPermissionPair": {
      "type": "object",
      "properties": {
        "request": {
          "$ref": "#/definitions/v1BulkCheckPermissionRequestItem"
        },
        "item": {
          "$ref": "#/definitions/v1BulkCheckPermissionResponseItem"
        },
        "error": {
          "$ref": "#/definitions/rpcStatus"
        }
      }
    },
    "v1BulkCheckPermissionRequest": {
      "type": "object",
      "properties": {
        "consistency": {
          "$ref": "#/definitions/v1Consistency"
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BulkCheckPermissionRequestItem"
          }
        }
      }
    },
    "v1BulkCheckPermissionRequestItem": {
      "type": "object",
      "properties": {
        "resource": {
          "$ref": "#/definitions/v1ObjectReference"
        },
        "permission": {
          "type": "string"
        },
        "subject": {
          "$ref": "#/definitions/v1SubjectReference"
        },
        "context": {
          "type": "object"
        }
      }
    },
    "v1BulkCheckPermissionResponse": {
      "type": "object",
      "properties": {
        "checkedAt": {
          "$ref": "#/definitions/v1ZedToken"
        },
        "pairs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BulkCheckPermissionPair"
          }
        }
      }
    },
    "v1BulkCheckPermissionResponseItem": {
      "type": "object",
      "properties": {
        "permissionship": {
          "$ref": "#/definitions/v1CheckPermissionResponsePermissionship"
        },
        "partialCaveatInfo": {
          "$ref": "#/definitions/v1PartialCaveatInfo"
        }
      }
    },
    "v1BulkExportRelationshipsRequest": {
      "type": "object",
      "properties": {
        "consistency": {
          "$ref": "#/definitions/v1Consistency"
        },
        "optionalLimit": {
          "type": "integer",
          "format": "int64",
          "description": "optional_limit, if non-zero, specifies the limit on the number of\nrelationships the server can return in one page. By default, the server\nwill pick a page size, and the server is free to choose a smaller size\nat will."
        },
        "optionalCursor": {
          "$ref": "#/definitions/v1Cursor",
          "description": "optional_cursor, if specified, indicates the cursor after which results\nshould resume being returned. The cursor can be found on the\nBulkExportRelationshipsResponse object."
        }
      },
      "description": "BulkExportRelationshipsRequest represents a resumable request for\nall relationships from the server."
    },
    "v1BulkExportRelationshipsResponse": {
      "type": "object",
      "properties": {
        "afterResultCursor": {
          "$ref": "#/definitions/v1Cursor"
        },
        "relationships": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Relationship"
          }
        }
      },
      "description": "BulkExportRelationshipsResponse is one page in a stream of relationship\ngroups that meet the criteria specified by the originating request. The\nserver will continue to stream back relationship groups as quickly as it can\nuntil all relationships have been transmitted back."
    },
    "v1BulkImportRelationshipsRequest": {
      "type": "object",
      "properties": {
        "relationships": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Relationship"
          }
        }
      },
      "description": "BulkImportRelationshipsRequest represents one batch of the streaming\nBulkImportRelationships API. The maximum size is only limited by the backing\ndatastore, and optimal size should be determined by the calling client\nexperimentally."
    },
    "v1BulkImportRelationshipsResponse": {
      "type": "object",
      "properties": {
        "numLoaded": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "BulkImportRelationshipsResponse is returned on successful completion of the\nbulk load stream, and contains the total number of relationships loaded."
    },
    "v1CheckPermissionRequest": {
      "type": "object",
      "properties": {
        "consistency": {
          "$ref": "#/definitions/v1Consistency"
        },
        "resource": {
          "$ref": "#/definitions/v1ObjectReference",
          "description": "resource is the resource on which to check the permission or relation."
        },
        "permission": {
          "type": "string",
          "description": "permission is the name of the permission (or relation) on which to execute\nthe check."
        },
        "subject": {
          "$ref": "#/definitions/v1SubjectReference",
          "description": "subject is the subject that will be checked for the permission or relation."
        },
        "context": {
          "type": "object",
          "title": "context consists of named values that are injected into the caveat evaluation context"
        }
      },
      "description": "CheckPermissionRequest issues a check on whether a subject has a permission\nor is a member of a relation, on a specific resource."
    },
    "v1CheckPermissionResponse": {
      "type": "object",
      "properties": {
        "checkedAt": {
          "$ref": "#/definitions/v1ZedToken"
        },
        "permissionship": {
          "$ref": "#/definitions/v1CheckPermissionResponsePermissionship",
          "description": "Permissionship communicates whether or not the subject has the requested\npermission or has a relationship with the given resource, over the given\nrelation.\n\nThis value will be authzed.api.v1.PERMISSIONSHIP_HAS_PERMISSION if the\nrequested subject is a member of the computed permission set or there\nexists a relationship with the requested relation from the given resource\nto the given subject."
        },
        "partialCaveatInfo": {
          "$ref": "#/definitions/v1PartialCaveatInfo",
          "title": "partial_caveat_info holds information of a partially-evaluated caveated response"
        }
      }
    },
    "v1CheckPermissionResponsePermissionship": {
      "type": "string",
      "enum": [
        "PERMISSIONSHIP_UNSPECIFIED",
        "PERMISSIONSHIP_NO_PERMISSION",
        "PERMISSIONSHIP_HAS_PERMISSION",
        "PERMISSIONSHIP_CONDITIONAL_PERMISSION"
      ],
      "default": "PERMISSIONSHIP_UNSPECIFIED"
    },
    "v1Consistency": {
      "type": "object",
      "properties": {
        "minimizeLatency": {
          "type": "boolean",
          "description": "minimize_latency indicates that the latency for the call should be\nminimized by having the system select the fastest snapshot available."
        },
        "atLeastAsFresh": {
          "$ref": "#/definitions/v1ZedToken",
          "description": "at_least_as_fresh indicates that all data used in the API call must be\n*at least as fresh* as that found in the ZedToken; more recent data might\nbe used if available or faster."
        },
        "atExactSnapshot": {
          "$ref": "#/definitions/v1ZedToken",
          "description": "at_exact_snapshot indicates that all data used in the API call must be\n*at the given* snapshot in time; if the snapshot is no longer available,\nan error will be returned to the caller."
        },
        "fullyConsistent": {
          "type": "boolean",
          "description": "fully_consistent indicates that all data used in the API call *must* be\nat the most recent snapshot found.\n\nNOTE: using this method can be *quite slow*, so unless there is a need to\ndo so, it is recommended to use `at_least_as_fresh` with a stored\nZedToken."
        }
      },
      "description": "Consistency will define how a request is handled by the backend.\nBy defining a consistency requirement, and a token at which those\nrequirements should be applied, where applicable."
    },
    "v1ContextualizedCaveat": {
      "type": "object",
      "properties": {
        "caveatName": {
          "type": "string",
          "title": "caveat_name is the name of the caveat expression to use, as defined in the schema"
        },
        "context": {
          "type": "object",
          "title": "context consists of any named values that are defined at write time for the caveat expression"
        }
      },
      "description": "ContextualizedCaveat represents a reference to a caveat to be used by caveated relationships.\nThe context consists of key-value pairs that will be injected at evaluation time.\nThe keys must match the arguments defined on the caveat in the schema."
    },
    "v1Cursor": {
      "type": "object",
      "properties": {
        "token": {
          "type": "string"
        }
      },
      "description": "Cursor is used to provide resumption of listing between calls to APIs\nsuch as LookupResources."
    },
    "v1DeleteRelationshipsRequest": {
      "type": "object",
      "properties": {
        "relationshipFilter": {
          "$ref": "#/definitions/v1RelationshipFilter"
        },
        "optionalPreconditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Precondition"
          },
          "title": "To be bounded by configuration"
        },
        "optionalLimit": {
          "type": "integer",
          "format": "int64",
          "description": "optional_limit, if non-zero, specifies the limit on the number of relationships to be deleted.\nIf there are more matching relationships found to be deleted than the limit specified here,\nthe deletion call will fail with an error to prevent partial deletion. If partial deletion\nis needed, specify below that partial deletion is allowed. Partial deletions can be used\nin a loop to delete large amounts of relationships in a *non-transactional* manner."
        },
        "optionalAllowPartialDeletions": {
          "type": "boolean",
          "description": "optional_allow_partial_deletions, if true and a limit is specified, will delete matching found\nrelationships up to the count specified in optional_limit, and no more."
        }
      },
      "description": "DeleteRelationshipsRequest specifies which Relationships should be deleted,\nrequesting the delete of *ALL* relationships that match the specified\nfilters. If the optional_preconditions parameter is included, all of the\nspecified preconditions must also be satisfied before the delete will be\nexecuted."
    },
    "v1DeleteRelationshipsResponse": {
      "type": "object",
      "properties": {
        "deletedAt": {
          "$ref": "#/definitions/v1ZedToken",
          "description": "deleted_at is the revision at which the relationships were deleted."
        },
        "deletionProgress": {
          "$ref": "#/definitions/DeleteRelationshipsResponseDeletionProgress",
          "description": "deletion_progress is an enumeration of the possible outcomes that occurred when attempting to delete the specified relationships."
        }
      }
    },
    "v1DirectSubjectSet": {
      "type": "object",
      "properties": {
        "subjects": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1SubjectReference"
          }
        }
      },
      "description": "DirectSubjectSet is a subject set which is simply a collection of subjects."
    },
    "v1ExpandPermissionTreeRequest": {
      "type": "object",
      "properties": {
        "consistency": {
          "$ref": "#/definitions/v1Consistency"
        },
        "resource": {
          "$ref": "#/definitions/v1ObjectReference",
          "description": "resource is the resource over which to run the expansion."
        },
        "permission": {
          "type": "string",
          "description": "permission is the name of the permission or relation over which to run the\nexpansion for the resource."
        }
      },
      "description": "ExpandPermissionTreeRequest returns a tree representing the expansion of all\nrelationships found accessible from a permission or relation on a particular\nresource.\n\nExpandPermissionTreeRequest is typically used to determine the full set of\nsubjects with a permission, along with the relationships that grant said\naccess."
    },
    "v1ExpandPermissionTreeResponse": {
      "type": "object",
      "properties": {
        "expandedAt": {
          "$ref": "#/definitions/v1ZedToken"
        },
        "treeRoot": {
          "$ref": "#/definitions/v1PermissionRelationshipTree",
          "description": "tree_root is a tree structure whose leaf nodes are subjects, and\nintermediate nodes represent the various operations (union, intersection,\nexclusion) to reach those subjects."
        }
      }
    },
    "v1LookupPermissionship": {
      "type": "string",
      "enum": [
        "LOOKUP_PERMISSIONSHIP_UNSPECIFIED",
        "LOOKUP_PERMISSIONSHIP_HAS_PERMISSION",
        "LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION"
      ],
      "default": "LOOKUP_PERMISSIONSHIP_UNSPECIFIED",
      "title": "LookupPermissionship represents whether a Lookup response was partially evaluated or not"
    },
    "v1LookupResourcesRequest": {
      "type": "object",
      "properties": {
        "consistency": {
          "$ref": "#/definitions/v1Consistency"
        },
        "resourceObjectType": {
          "type": "string",
          "description": "resource_object_type is the type of resource object for which the IDs will\nbe returned."
        },
        "permission": {
          "type": "string",
          "description": "permission is the name of the permission or relation for which the subject\nmust Check."
        },
        "subject": {
          "$ref": "#/definitions/v1SubjectReference",
          "description": "subject is the subject with access to the resources."
        },
        "context": {
          "type": "object",
          "title": "context consists of named values that are injected into the caveat evaluation context"
        },
        "optionalLimit": {
          "type": "integer",
          "format": "int64",
          "description": "optional_limit, if non-zero, specifies the limit on the number of resources to return\nbefore the stream is closed on the server side. By default, the stream will continue\nresolving resources until exhausted or the stream is closed due to the client or a\nnetwork issue."
        },
        "optionalCursor": {
          "$ref": "#/definitions/v1Cursor",
          "description": "optional_cursor, if specified, indicates the cursor after which results should resume being returned.\nThe cursor can be found on the LookupResourcesResponse object."
        }
      },
      "description": "LookupResourcesRequest performs a lookup of all resources of a particular\nkind on which the subject has the specified permission or the relation in\nwhich the subject exists, streaming back the IDs of those resources."
    },
    "v1LookupResourcesResponse": {
      "type": "object",
      "properties": {
        "lookedUpAt": {
          "$ref": "#/definitions/v1ZedToken",
          "description": "looked_up_at is the ZedToken at which the resource was found."
        },
        "resourceObjectId": {
          "type": "string",
          "description": "resource_object_id is the object ID of the found resource."
        },
        "permissionship": {
          "$ref": "#/definitions/v1LookupPermissionship",
          "title": "permissionship indicates whether the response was partially evaluated or not"
        },
        "partialCaveatInfo": {
          "$ref": "#/definitions/v1PartialCaveatInfo",
          "title": "partial_caveat_info holds information of a partially-evaluated caveated response"
        },
        "afterResultCursor": {
          "$ref": "#/definitions/v1Cursor",
          "description": "after_result_cursor holds a cursor that can be used to resume the LookupResources stream after this\nresult."
        }
      },
      "description": "LookupResourcesResponse contains a single matching resource object ID for the\nrequested object type, permission, and subject."
    },
    "v1LookupSubjectsRequest": {
      "type": "object",
      "properties": {
        "consistency": {
          "$ref": "#/definitions/v1Consistency"
        },
        "resource": {
          "$ref": "#/definitions/v1ObjectReference",
          "description": "resource is the resource for which all matching subjects for the permission\nor relation will be returned."
        },
        "permission": {
          "type": "string",
          "description": "permission is the name of the permission (or relation) for which to find\nthe subjects."
        },
        "subjectObjectType": {
          "type": "string",
          "description": "subject_object_type is the type of subject object for which the IDs will\nbe returned."
        },
        "optionalSubjectRelation": {
          "type": "string",
          "description": "optional_subject_relation is the optional relation for the subject."
        },
        "context": {
          "type": "object",
          "title": "context consists of named values that are injected into the caveat evaluation context"
        },
        "optionalConcreteLimit": {
          "type": "integer",
          "format": "int64",
          "description": "optional_concrete_limit, if non-zero, specifies the limit on the number of\n*concrete* (non-wildcard) subjects to return before the stream is closed on the\nserver side. With the default value of zero, the stream will continue resolving\nconcrete subjects until exhausted or the stream is closed due to the client or\na network issue.\n\nNOTE: Wildcard subjects (\"*\") have special treatment when cursors and limits are used. Because\nwildcards can apply to *any* concrete subjects, if a wildcard subject is found within the dataset,\na wildcard subject can be returned for *all* LookupSubjects calls, regardless of the cursor or\nlimit.\n\nFor example, if wildcards are requested, a wildcard subject exists, there is a specified limit\nof 10 concrete subjects, and at least 10 concrete subjects exist, the API will return 11 subjects\nin total: the 10 concrete + the wildcard\n\nFurthermore, if a wildcard has a set of exclusions generated by the dataset,\nthe exclusions *will respect the cursor* and only a *partial* set of exclusions will be returned\nfor each invocation of the API.\n\n***IT IS UP TO THE CALLER IN THIS CASE TO COMBINE THE EXCLUSIONS IF DESIRED***"
        },
        "optionalCursor": {
          "$ref": "#/definitions/v1Cursor",
          "description": "optional_cursor, if specified, indicates the cursor after which results should resume being returned.\nThe cursor can be found on the LookupSubjectsResponse object.\n\nNOTE: See above for notes about how cursors interact with wildcard subjects."
        },
        "wildcardOption": {
          "$ref": "#/definitions/LookupSubjectsRequestWildcardOption",
          "description": "wildcard_option specifies whether wildcards should be returned by LookupSubjects.\nFor backwards compatibility, defaults to WILDCARD_OPTION_INCLUDE_WILDCARDS if unspecified."
        }
      },
      "description": "LookupSubjectsRequest performs a lookup of all subjects of a particular\nkind for which the subject has the specified permission or the relation in\nwhich the subject exists, streaming back the IDs of those subjects."
    },
    "v1LookupSubjectsResponse": {
      "type": "object",
      "properties": {
        "lookedUpAt": {
          "$ref": "#/definitions/v1ZedToken"
        },
        "subjectObjectId": {
          "type": "string",
          "title": "subject_object_id is the Object ID of the subject found. May be a `*` if\na wildcard was found.\ndeprecated: use `subject`"
        },
        "excludedSubjectIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "excluded_subject_ids are the Object IDs of the subjects excluded. This list\nwill only contain object IDs if `subject_object_id` is a wildcard (`*`) and\nwill only be populated if exclusions exist from the wildcard.\ndeprecated: use `excluded_subjects`"
        },
        "permissionship": {
          "$ref": "#/definitions/v1LookupPermissionship",
          "title": "permissionship indicates whether the response was partially evaluated or not\ndeprecated: use `subject.permissionship`"
        },
        "partialCaveatInfo": {
          "$ref": "#/definitions/v1PartialCaveatInfo",
          "title": "partial_caveat_info holds information of a partially-evaluated caveated response\ndeprecated: use `subject.partial_caveat_info`"
        },
        "subject": {
          "$ref": "#/definitions/v1ResolvedSubject",
          "description": "subject is the subject found, along with its permissionship."
        },
        "excludedSubjects": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ResolvedSubject"
          },
          "description": "excluded_subjects are the subjects excluded. This list\nwill only contain subjects if `subject.subject_object_id` is a wildcard (`*`) and\nwill only be populated if exclusions exist from the wildcard."
        },
        "afterResultCursor": {
          "$ref": "#/definitions/v1Cursor",
          "description": "after_result_cursor holds a cursor that can be used to resume the LookupSubjects stream after this\nresult."
        }
      },
      "description": "LookupSubjectsResponse contains a single matching subject object ID for the\nrequested subject object type on the permission or relation."
    },
    "v1ObjectReference": {
      "type": "object",
      "properties": {
        "objectType": {
          "type": "string"
        },
        "objectId": {
          "type": "string"
        }
      },
      "description": "ObjectReference is used to refer to a specific object in the system."
    },
    "v1PartialCaveatInfo": {
      "type": "object",
      "properties": {
        "missingRequiredContext": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "missing_required_context is a list of one or more fields that were missing and prevented caveats\nfrom being fully evaluated"
        }
      },
      "title": "PartialCaveatInfo carries information necessary for the client to take action\nin the event a response contains a partially evaluated caveat"
    },
    "v1PermissionRelationshipTree": {
      "type": "object",
      "properties": {
        "intermediate": {
          "$ref": "#/definitions/v1AlgebraicSubjectSet"
        },
        "leaf": {
          "$ref": "#/definitions/v1DirectSubjectSet"
        },
        "expandedObject": {
          "$ref": "#/definitions/v1ObjectReference"
        },
        "expandedRelation": {
          "type": "string"
        }
      },
      "description": "PermissionRelationshipTree is used for representing a tree of a resource and\nits permission relationships with other objects."
    },
    "v1Precondition": {
      "type": "object",
      "properties": {
        "operation": {
          "$ref": "#/definitions/v1PreconditionOperation"
        },
        "filter": {
          "$ref": "#/definitions/v1RelationshipFilter"
        }
      },
      "description": "Precondition specifies how and the existence or absence of certain\nrelationships as expressed through the accompanying filter should affect\nwhether or not the operation proceeds.\n\nMUST_NOT_MATCH will fail the parent request if any relationships match the\nrelationships filter.\nMUST_MATCH will fail the parent request if there are no\nrelationships that match the filter."
    },
    "v1PreconditionOperation": {
      "type": "string",
      "enum": [
        "OPERATION_UNSPECIFIED",
        "OPERATION_MUST_NOT_MATCH",
        "OPERATION_MUST_MATCH"
      ],
      "default": "OPERATION_UNSPECIFIED"
    },
    "v1ReadRelationshipsRequest": {
      "type": "object",
      "properties": {
        "consistency": {
          "$ref": "#/definitions/v1Consistency"
        },
        "relationshipFilter": {
          "$ref": "#/definitions/v1RelationshipFilter",
          "description": "relationship_filter defines the filter to be applied to the relationships\nto be returned."
        },
        "optionalLimit": {
          "type": "integer",
          "format": "int64",
          "description": "optional_limit, if non-zero, specifies the limit on the number of relationships to return\nbefore the stream is closed on the server side. By default, the stream will continue\nresolving relationships until exhausted or the stream is closed due to the client or a\nnetwork issue."
        },
        "optionalCursor": {
          "$ref": "#/definitions/v1Cursor",
          "description": "optional_cursor, if specified, indicates the cursor after which results should resume being returned.\nThe cursor can be found on the ReadRelationshipsResponse object."
        }
      },
      "description": "ReadRelationshipsRequest specifies one or more filters used to read matching\nrelationships within the system."
    },
    "v1ReadRelationshipsResponse": {
      "type": "object",
      "properties": {
        "readAt": {
          "$ref": "#/definitions/v1ZedToken",
          "description": "read_at is the ZedToken at which the relationship was found."
        },
        "relationship": {
          "$ref": "#/definitions/v1Relationship",
          "description": "relationship is the found relationship."
        },
        "afterResultCursor": {
          "$ref": "#/definitions/v1Cursor",
          "description": "after_result_cursor holds a cursor that can be used to resume the ReadRelationships stream after this\nresult."
        }
      },
      "description": "ReadRelationshipsResponse contains a Relationship found that matches the\nspecified relationship filter(s). A instance of this response message will\nbe streamed to the client for each relationship found."
    },
    "v1Relationship": {
      "type": "object",
      "properties": {
        "resource": {
          "$ref": "#/definitions/v1ObjectReference",
          "title": "resource is the resource to which the subject is related, in some manner"
        },
        "relation": {
          "type": "string",
          "description": "relation is how the resource and subject are related."
        },
        "subject": {
          "$ref": "#/definitions/v1SubjectReference",
          "description": "subject is the subject to which the resource is related, in some manner."
        },
        "optionalCaveat": {
          "$ref": "#/definitions/v1ContextualizedCaveat",
          "title": "optional_caveat is a reference to a the caveat that must be enforced over the relationship"
        }
      },
      "description": "Relationship specifies how a resource relates to a subject. Relationships\nform the data for the graph over which all permissions questions are\nanswered."
    },
    "v1RelationshipFilter": {
      "type": "object",
      "properties": {
        "resourceType": {
          "type": "string"
        },
        "optionalResourceId": {
          "type": "string"
        },
        "optionalRelation": {
          "type": "string"
        },
        "optionalSubjectFilter": {
          "$ref": "#/definitions/v1SubjectFilter"
        }
      },
      "description": "RelationshipFilter is a collection of filters which when applied to a\nrelationship will return relationships that have exactly matching fields.\n\nresource_type is required. All other fields are optional and if left\nunspecified will not filter relationships."
    },
    "v1RelationshipUpdate": {
      "type": "object",
      "properties": {
        "operation": {
          "$ref": "#/definitions/v1RelationshipUpdateOperation"
        },
        "relationship": {
          "$ref": "#/definitions/v1Relationship"
        }
      },
      "description": "RelationshipUpdate is used for mutating a single relationship within the\nservice.\n\nCREATE will create the relationship only if it doesn't exist, and error\notherwise.\n\nTOUCH will upsert the relationship, and will not error if it\nalready exists.\n\nDELETE will delete the relationship. If the relationship does not exist,\nthis operation will no-op."
    },
    "v1RelationshipUpdateOperation": {
      "type": "string",
      "enum": [
        "OPERATION_UNSPECIFIED",
        "OPERATION_CREATE",
        "OPERATION_TOUCH",
        "OPERATION_DELETE"
      ],
      "default": "OPERATION_UNSPECIFIED"
    },
    "v1ResolvedSubject": {
      "type": "object",
      "properties": {
        "subjectObjectId": {
          "type": "string",
          "description": "subject_object_id is the Object ID of the subject found. May be a `*` if\na wildcard was found."
        },
        "permissionship": {
          "$ref": "#/definitions/v1LookupPermissionship",
          "title": "permissionship indicates whether the response was partially evaluated or not"
        },
        "partialCaveatInfo": {
          "$ref": "#/definitions/v1PartialCaveatInfo",
          "title": "partial_caveat_info holds information of a partially-evaluated caveated response"
        }
      },
      "description": "ResolvedSubject is a single subject resolved within LookupSubjects."
    },
    "v1StreamingBulkCheckPermissionRequest": {
      "type": "object",
      "properties": {
        "consistency": {
          "$ref": "#/definitions/v1Consistency"
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BulkCheckPermissionRequestItem"
          }
        }
      }
    },
    "v1StreamingBulkCheckPermissionResponse": {
      "type": "object",
      "properties": {
        "checkedAt": {
          "$ref": "#/definitions/v1ZedToken"
        },
        "pairs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BulkCheckPermissionPair"
          }
        }
      }
    },
    "v1SubjectFilter": {
      "type": "object",
      "properties": {
        "subjectType": {
          "type": "string"
        },
        "optionalSubjectId": {
          "type": "string"
        },
        "optionalRelation": {
          "$ref": "#/definitions/SubjectFilterRelationFilter"
        }
      },
      "description": "SubjectFilter specifies a filter on the subject of a relationship.\n\nsubject_type is required and all other fields are optional, and will not\nimpose any additional requirements if left unspecified."
    },
    "v1SubjectReference": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ObjectReference"
        },
        "optionalRelation": {
          "type": "string"
        }
      },
      "title": "SubjectReference is used for referring to the subject portion of a\nRelationship. The relation component is optional and is used for defining a\nsub-relation on the subject, e.g. group:123#members"
    },
    "v1WatchRequest": {
      "type": "object",
      "properties": {
        "optionalObjectTypes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "optionalStartCursor": {
          "$ref": "#/definitions/v1ZedToken",
          "description": "optional_start_cursor is the ZedToken holding the point-in-time at\nwhich to start watching for changes.\nIf not specified, the watch will begin at the current head revision\nof the datastore, returning any updates that occur after the caller\nmakes the request.\nNote that if this cursor references a point-in-time containing data\nthat has been garbage collected, an error will be returned."
        }
      },
      "description": "WatchRequest specifies the object definitions for which we want to start\nwatching mutations, and an optional start snapshot for when to start\nwatching."
    },
    "v1WatchResponse": {
      "type": "object",
      "properties": {
        "updates": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1RelationshipUpdate"
          }
        },
        "changesThrough": {
          "$ref": "#/definitions/v1ZedToken"
        }
      },
      "description": "WatchResponse contains all tuple modification events in ascending\ntimestamp order, from the requested start snapshot to a snapshot\nencoded in the watch response. The client can use the snapshot to resume\nwatching where the previous watch response left off."
    },
    "v1WriteRelationshipsRequest": {
      "type": "object",
      "properties": {
        "updates": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1RelationshipUpdate"
          }
        },
        "optionalPreconditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Precondition"
          },
          "title": "To be bounded by configuration"
        }
      },
      "description": "WriteRelationshipsRequest contains a list of Relationship mutations that\nshould be applied to the service. If the optional_preconditions parameter\nis included, all of the specified preconditions must also be satisfied before\nthe write will be committed."
    },
    "v1WriteRelationshipsResponse": {
      "type": "object",
      "properties": {
        "writtenAt": {
          "$ref": "#/definitions/v1ZedToken"
        }
      }
    },
    "v1ZedToken": {
      "type": "object",
      "properties": {
        "token": {
          "type": "string"
        }
      },
      "description": "ZedToken is used to provide causality metadata between Write and Check\nrequests.\n\nSee the authzed.api.v1.Consistency message for more information."
    },
    "v1alpha1PermissionUpdate": {
      "type": "object",
      "properties": {
        "subject": {
          "$ref": "#/definitions/v1SubjectReference",
          "description": "subject defines the subject resource whose permissions have changed."
        },
        "resource": {
          "$ref": "#/definitions/v1ObjectReference",
          "description": "resource defines the specific object in the system."
        },
        "relation": {
          "type": "string"
        },
        "updatedPermission": {
          "$ref": "#/definitions/v1alpha1PermissionUpdatePermissionship"
        }
      },
      "description": "PermissionUpdate represents a single permission update for a specific\nsubject's permissions."
    },
    "v1alpha1PermissionUpdatePermissionship": {
      "type": "string",
      "enum": [
        "PERMISSIONSHIP_UNSPECIFIED",
        "PERMISSIONSHIP_NO_PERMISSION",
        "PERMISSIONSHIP_HAS_PERMISSION"
      ],
      "default": "PERMISSIONSHIP_UNSPECIFIED",
      "description": "todo: work this into the v1 core API at some point since it's used\nacross services."
    },
    "v1alpha1WatchResourcesRequest": {
      "type": "object",
      "properties": {
        "resourceObjectType": {
          "type": "string",
          "description": "resource_object_type is the type of resource object for which we will\nwatch for changes."
        },
        "permission": {
          "type": "string",
          "description": "permission is the name of the permission or relation for which we will\nwatch for changes."
        },
        "subjectObjectType": {
          "type": "string",
          "description": "subject_object_type is the type of the subject resource for which we will\nwatch for changes."
        },
        "optionalSubjectRelation": {
          "type": "string",
          "description": "optional_subject_relation allows you to specify a group of subjects to watch\nfor a given subject type."
        },
        "optionalStartCursor": {
          "$ref": "#/definitions/v1ZedToken"
        }
      },
      "description": "WatchResourcesRequest starts a watch for specific permission updates\nfor the given resource and subject types."
    },
    "v1alpha1WatchResourcesResponse": {
      "type": "object",
      "properties": {
        "updates": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1PermissionUpdate"
          }
        },
        "changesThrough": {
          "$ref": "#/definitions/v1ZedToken"
        }
      },
      "description": "WatchResourcesResponse enumerates the list of permission updates that have\noccurred as a result of one or more relationship updates."
    }
  },
  "securityDefinitions": {
    "ApiKeyAuth": {
      "type": "apiKey",
      "name": "Authorization",
      "in": "header"
    }
  },
  "externalDocs": {
    "description": "More about the Authzed API.",
    "url": "https://docs.authzed.com/reference/api"
  }
}
