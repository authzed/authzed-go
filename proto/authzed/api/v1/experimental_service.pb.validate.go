// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: authzed/api/v1/experimental_service.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on
// ExperimentalRegisterRelationshipCounterRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExperimentalRegisterRelationshipCounterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExperimentalRegisterRelationshipCounterRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ExperimentalRegisterRelationshipCounterRequestMultiError, or nil if none found.
func (m *ExperimentalRegisterRelationshipCounterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalRegisterRelationshipCounterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) > 64 {
		err := ExperimentalRegisterRelationshipCounterRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ExperimentalRegisterRelationshipCounterRequest_Name_Pattern.MatchString(m.GetName()) {
		err := ExperimentalRegisterRelationshipCounterRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetRelationshipFilter() == nil {
		err := ExperimentalRegisterRelationshipCounterRequestValidationError{
			field:  "RelationshipFilter",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRelationshipFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalRegisterRelationshipCounterRequestValidationError{
					field:  "RelationshipFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalRegisterRelationshipCounterRequestValidationError{
					field:  "RelationshipFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelationshipFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalRegisterRelationshipCounterRequestValidationError{
				field:  "RelationshipFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExperimentalRegisterRelationshipCounterRequestMultiError(errors)
	}

	return nil
}

// ExperimentalRegisterRelationshipCounterRequestMultiError is an error
// wrapping multiple validation errors returned by
// ExperimentalRegisterRelationshipCounterRequest.ValidateAll() if the
// designated constraints aren't met.
type ExperimentalRegisterRelationshipCounterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalRegisterRelationshipCounterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalRegisterRelationshipCounterRequestMultiError) AllErrors() []error { return m }

// ExperimentalRegisterRelationshipCounterRequestValidationError is the
// validation error returned by
// ExperimentalRegisterRelationshipCounterRequest.Validate if the designated
// constraints aren't met.
type ExperimentalRegisterRelationshipCounterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalRegisterRelationshipCounterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalRegisterRelationshipCounterRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ExperimentalRegisterRelationshipCounterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalRegisterRelationshipCounterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalRegisterRelationshipCounterRequestValidationError) ErrorName() string {
	return "ExperimentalRegisterRelationshipCounterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalRegisterRelationshipCounterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalRegisterRelationshipCounterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalRegisterRelationshipCounterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalRegisterRelationshipCounterRequestValidationError{}

var _ExperimentalRegisterRelationshipCounterRequest_Name_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

// Validate checks the field values on
// ExperimentalRegisterRelationshipCounterResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExperimentalRegisterRelationshipCounterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExperimentalRegisterRelationshipCounterResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ExperimentalRegisterRelationshipCounterResponseMultiError, or nil if none found.
func (m *ExperimentalRegisterRelationshipCounterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalRegisterRelationshipCounterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExperimentalRegisterRelationshipCounterResponseMultiError(errors)
	}

	return nil
}

// ExperimentalRegisterRelationshipCounterResponseMultiError is an error
// wrapping multiple validation errors returned by
// ExperimentalRegisterRelationshipCounterResponse.ValidateAll() if the
// designated constraints aren't met.
type ExperimentalRegisterRelationshipCounterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalRegisterRelationshipCounterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalRegisterRelationshipCounterResponseMultiError) AllErrors() []error { return m }

// ExperimentalRegisterRelationshipCounterResponseValidationError is the
// validation error returned by
// ExperimentalRegisterRelationshipCounterResponse.Validate if the designated
// constraints aren't met.
type ExperimentalRegisterRelationshipCounterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalRegisterRelationshipCounterResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ExperimentalRegisterRelationshipCounterResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ExperimentalRegisterRelationshipCounterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalRegisterRelationshipCounterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalRegisterRelationshipCounterResponseValidationError) ErrorName() string {
	return "ExperimentalRegisterRelationshipCounterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalRegisterRelationshipCounterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalRegisterRelationshipCounterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalRegisterRelationshipCounterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalRegisterRelationshipCounterResponseValidationError{}

// Validate checks the field values on ExperimentalCountRelationshipsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExperimentalCountRelationshipsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExperimentalCountRelationshipsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExperimentalCountRelationshipsRequestMultiError, or nil if none found.
func (m *ExperimentalCountRelationshipsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalCountRelationshipsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) > 64 {
		err := ExperimentalCountRelationshipsRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ExperimentalCountRelationshipsRequest_Name_Pattern.MatchString(m.GetName()) {
		err := ExperimentalCountRelationshipsRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExperimentalCountRelationshipsRequestMultiError(errors)
	}

	return nil
}

// ExperimentalCountRelationshipsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ExperimentalCountRelationshipsRequest.ValidateAll() if the designated
// constraints aren't met.
type ExperimentalCountRelationshipsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalCountRelationshipsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalCountRelationshipsRequestMultiError) AllErrors() []error { return m }

// ExperimentalCountRelationshipsRequestValidationError is the validation error
// returned by ExperimentalCountRelationshipsRequest.Validate if the
// designated constraints aren't met.
type ExperimentalCountRelationshipsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalCountRelationshipsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalCountRelationshipsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalCountRelationshipsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalCountRelationshipsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalCountRelationshipsRequestValidationError) ErrorName() string {
	return "ExperimentalCountRelationshipsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalCountRelationshipsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalCountRelationshipsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalCountRelationshipsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalCountRelationshipsRequestValidationError{}

var _ExperimentalCountRelationshipsRequest_Name_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

// Validate checks the field values on ExperimentalCountRelationshipsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExperimentalCountRelationshipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExperimentalCountRelationshipsResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ExperimentalCountRelationshipsResponseMultiError, or nil if none found.
func (m *ExperimentalCountRelationshipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalCountRelationshipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.CounterResult.(type) {
	case *ExperimentalCountRelationshipsResponse_CounterStillCalculating:
		if v == nil {
			err := ExperimentalCountRelationshipsResponseValidationError{
				field:  "CounterResult",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for CounterStillCalculating
	case *ExperimentalCountRelationshipsResponse_ReadCounterValue:
		if v == nil {
			err := ExperimentalCountRelationshipsResponseValidationError{
				field:  "CounterResult",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReadCounterValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExperimentalCountRelationshipsResponseValidationError{
						field:  "ReadCounterValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExperimentalCountRelationshipsResponseValidationError{
						field:  "ReadCounterValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReadCounterValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExperimentalCountRelationshipsResponseValidationError{
					field:  "ReadCounterValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExperimentalCountRelationshipsResponseMultiError(errors)
	}

	return nil
}

// ExperimentalCountRelationshipsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ExperimentalCountRelationshipsResponse.ValidateAll() if the designated
// constraints aren't met.
type ExperimentalCountRelationshipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalCountRelationshipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalCountRelationshipsResponseMultiError) AllErrors() []error { return m }

// ExperimentalCountRelationshipsResponseValidationError is the validation
// error returned by ExperimentalCountRelationshipsResponse.Validate if the
// designated constraints aren't met.
type ExperimentalCountRelationshipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalCountRelationshipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalCountRelationshipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalCountRelationshipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalCountRelationshipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalCountRelationshipsResponseValidationError) ErrorName() string {
	return "ExperimentalCountRelationshipsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalCountRelationshipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalCountRelationshipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalCountRelationshipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalCountRelationshipsResponseValidationError{}

// Validate checks the field values on ReadCounterValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadCounterValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadCounterValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadCounterValueMultiError, or nil if none found.
func (m *ReadCounterValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadCounterValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RelationshipCount

	if m.GetReadAt() == nil {
		err := ReadCounterValueValidationError{
			field:  "ReadAt",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadCounterValueValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadCounterValueValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadCounterValueValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadCounterValueMultiError(errors)
	}

	return nil
}

// ReadCounterValueMultiError is an error wrapping multiple validation errors
// returned by ReadCounterValue.ValidateAll() if the designated constraints
// aren't met.
type ReadCounterValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadCounterValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadCounterValueMultiError) AllErrors() []error { return m }

// ReadCounterValueValidationError is the validation error returned by
// ReadCounterValue.Validate if the designated constraints aren't met.
type ReadCounterValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadCounterValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadCounterValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadCounterValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadCounterValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadCounterValueValidationError) ErrorName() string { return "ReadCounterValueValidationError" }

// Error satisfies the builtin error interface
func (e ReadCounterValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadCounterValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadCounterValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadCounterValueValidationError{}

// Validate checks the field values on
// ExperimentalUnregisterRelationshipCounterRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExperimentalUnregisterRelationshipCounterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExperimentalUnregisterRelationshipCounterRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ExperimentalUnregisterRelationshipCounterRequestMultiError, or nil if none found.
func (m *ExperimentalUnregisterRelationshipCounterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalUnregisterRelationshipCounterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) > 64 {
		err := ExperimentalUnregisterRelationshipCounterRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ExperimentalUnregisterRelationshipCounterRequest_Name_Pattern.MatchString(m.GetName()) {
		err := ExperimentalUnregisterRelationshipCounterRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExperimentalUnregisterRelationshipCounterRequestMultiError(errors)
	}

	return nil
}

// ExperimentalUnregisterRelationshipCounterRequestMultiError is an error
// wrapping multiple validation errors returned by
// ExperimentalUnregisterRelationshipCounterRequest.ValidateAll() if the
// designated constraints aren't met.
type ExperimentalUnregisterRelationshipCounterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalUnregisterRelationshipCounterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalUnregisterRelationshipCounterRequestMultiError) AllErrors() []error { return m }

// ExperimentalUnregisterRelationshipCounterRequestValidationError is the
// validation error returned by
// ExperimentalUnregisterRelationshipCounterRequest.Validate if the designated
// constraints aren't met.
type ExperimentalUnregisterRelationshipCounterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalUnregisterRelationshipCounterRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ExperimentalUnregisterRelationshipCounterRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ExperimentalUnregisterRelationshipCounterRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ExperimentalUnregisterRelationshipCounterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalUnregisterRelationshipCounterRequestValidationError) ErrorName() string {
	return "ExperimentalUnregisterRelationshipCounterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalUnregisterRelationshipCounterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalUnregisterRelationshipCounterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalUnregisterRelationshipCounterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalUnregisterRelationshipCounterRequestValidationError{}

var _ExperimentalUnregisterRelationshipCounterRequest_Name_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

// Validate checks the field values on
// ExperimentalUnregisterRelationshipCounterResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExperimentalUnregisterRelationshipCounterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExperimentalUnregisterRelationshipCounterResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ExperimentalUnregisterRelationshipCounterResponseMultiError, or nil if none found.
func (m *ExperimentalUnregisterRelationshipCounterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalUnregisterRelationshipCounterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExperimentalUnregisterRelationshipCounterResponseMultiError(errors)
	}

	return nil
}

// ExperimentalUnregisterRelationshipCounterResponseMultiError is an error
// wrapping multiple validation errors returned by
// ExperimentalUnregisterRelationshipCounterResponse.ValidateAll() if the
// designated constraints aren't met.
type ExperimentalUnregisterRelationshipCounterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalUnregisterRelationshipCounterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalUnregisterRelationshipCounterResponseMultiError) AllErrors() []error { return m }

// ExperimentalUnregisterRelationshipCounterResponseValidationError is the
// validation error returned by
// ExperimentalUnregisterRelationshipCounterResponse.Validate if the
// designated constraints aren't met.
type ExperimentalUnregisterRelationshipCounterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalUnregisterRelationshipCounterResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ExperimentalUnregisterRelationshipCounterResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ExperimentalUnregisterRelationshipCounterResponseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ExperimentalUnregisterRelationshipCounterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalUnregisterRelationshipCounterResponseValidationError) ErrorName() string {
	return "ExperimentalUnregisterRelationshipCounterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalUnregisterRelationshipCounterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalUnregisterRelationshipCounterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalUnregisterRelationshipCounterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalUnregisterRelationshipCounterResponseValidationError{}

// Validate checks the field values on BulkCheckPermissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkCheckPermissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkCheckPermissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BulkCheckPermissionRequestMultiError, or nil if none found.
func (m *BulkCheckPermissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkCheckPermissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkCheckPermissionRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkCheckPermissionRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkCheckPermissionRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if item == nil {
			err := BulkCheckPermissionRequestValidationError{
				field:  fmt.Sprintf("Items[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkCheckPermissionRequestValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkCheckPermissionRequestValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkCheckPermissionRequestValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkCheckPermissionRequestMultiError(errors)
	}

	return nil
}

// BulkCheckPermissionRequestMultiError is an error wrapping multiple
// validation errors returned by BulkCheckPermissionRequest.ValidateAll() if
// the designated constraints aren't met.
type BulkCheckPermissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkCheckPermissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkCheckPermissionRequestMultiError) AllErrors() []error { return m }

// BulkCheckPermissionRequestValidationError is the validation error returned
// by BulkCheckPermissionRequest.Validate if the designated constraints aren't met.
type BulkCheckPermissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkCheckPermissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkCheckPermissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkCheckPermissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkCheckPermissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkCheckPermissionRequestValidationError) ErrorName() string {
	return "BulkCheckPermissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BulkCheckPermissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkCheckPermissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkCheckPermissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkCheckPermissionRequestValidationError{}

// Validate checks the field values on BulkCheckPermissionRequestItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkCheckPermissionRequestItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkCheckPermissionRequestItem with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkCheckPermissionRequestItemMultiError, or nil if none found.
func (m *BulkCheckPermissionRequestItem) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkCheckPermissionRequestItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetResource() == nil {
		err := BulkCheckPermissionRequestItemValidationError{
			field:  "Resource",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkCheckPermissionRequestItemValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkCheckPermissionRequestItemValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkCheckPermissionRequestItemValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetPermission()) > 64 {
		err := BulkCheckPermissionRequestItemValidationError{
			field:  "Permission",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BulkCheckPermissionRequestItem_Permission_Pattern.MatchString(m.GetPermission()) {
		err := BulkCheckPermissionRequestItemValidationError{
			field:  "Permission",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSubject() == nil {
		err := BulkCheckPermissionRequestItemValidationError{
			field:  "Subject",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkCheckPermissionRequestItemValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkCheckPermissionRequestItemValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkCheckPermissionRequestItemValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkCheckPermissionRequestItemValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkCheckPermissionRequestItemValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkCheckPermissionRequestItemValidationError{
				field:  "Context",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BulkCheckPermissionRequestItemMultiError(errors)
	}

	return nil
}

// BulkCheckPermissionRequestItemMultiError is an error wrapping multiple
// validation errors returned by BulkCheckPermissionRequestItem.ValidateAll()
// if the designated constraints aren't met.
type BulkCheckPermissionRequestItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkCheckPermissionRequestItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkCheckPermissionRequestItemMultiError) AllErrors() []error { return m }

// BulkCheckPermissionRequestItemValidationError is the validation error
// returned by BulkCheckPermissionRequestItem.Validate if the designated
// constraints aren't met.
type BulkCheckPermissionRequestItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkCheckPermissionRequestItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkCheckPermissionRequestItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkCheckPermissionRequestItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkCheckPermissionRequestItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkCheckPermissionRequestItemValidationError) ErrorName() string {
	return "BulkCheckPermissionRequestItemValidationError"
}

// Error satisfies the builtin error interface
func (e BulkCheckPermissionRequestItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkCheckPermissionRequestItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkCheckPermissionRequestItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkCheckPermissionRequestItemValidationError{}

var _BulkCheckPermissionRequestItem_Permission_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

// Validate checks the field values on BulkCheckPermissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkCheckPermissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkCheckPermissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BulkCheckPermissionResponseMultiError, or nil if none found.
func (m *BulkCheckPermissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkCheckPermissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCheckedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkCheckPermissionResponseValidationError{
					field:  "CheckedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkCheckPermissionResponseValidationError{
					field:  "CheckedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkCheckPermissionResponseValidationError{
				field:  "CheckedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPairs() {
		_, _ = idx, item

		if item == nil {
			err := BulkCheckPermissionResponseValidationError{
				field:  fmt.Sprintf("Pairs[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkCheckPermissionResponseValidationError{
						field:  fmt.Sprintf("Pairs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkCheckPermissionResponseValidationError{
						field:  fmt.Sprintf("Pairs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkCheckPermissionResponseValidationError{
					field:  fmt.Sprintf("Pairs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkCheckPermissionResponseMultiError(errors)
	}

	return nil
}

// BulkCheckPermissionResponseMultiError is an error wrapping multiple
// validation errors returned by BulkCheckPermissionResponse.ValidateAll() if
// the designated constraints aren't met.
type BulkCheckPermissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkCheckPermissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkCheckPermissionResponseMultiError) AllErrors() []error { return m }

// BulkCheckPermissionResponseValidationError is the validation error returned
// by BulkCheckPermissionResponse.Validate if the designated constraints
// aren't met.
type BulkCheckPermissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkCheckPermissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkCheckPermissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkCheckPermissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkCheckPermissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkCheckPermissionResponseValidationError) ErrorName() string {
	return "BulkCheckPermissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BulkCheckPermissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkCheckPermissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkCheckPermissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkCheckPermissionResponseValidationError{}

// Validate checks the field values on BulkCheckPermissionPair with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkCheckPermissionPair) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkCheckPermissionPair with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BulkCheckPermissionPairMultiError, or nil if none found.
func (m *BulkCheckPermissionPair) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkCheckPermissionPair) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkCheckPermissionPairValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkCheckPermissionPairValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkCheckPermissionPairValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Response.(type) {
	case *BulkCheckPermissionPair_Item:
		if v == nil {
			err := BulkCheckPermissionPairValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetItem()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkCheckPermissionPairValidationError{
						field:  "Item",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkCheckPermissionPairValidationError{
						field:  "Item",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkCheckPermissionPairValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BulkCheckPermissionPair_Error:
		if v == nil {
			err := BulkCheckPermissionPairValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetError()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkCheckPermissionPairValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkCheckPermissionPairValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkCheckPermissionPairValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return BulkCheckPermissionPairMultiError(errors)
	}

	return nil
}

// BulkCheckPermissionPairMultiError is an error wrapping multiple validation
// errors returned by BulkCheckPermissionPair.ValidateAll() if the designated
// constraints aren't met.
type BulkCheckPermissionPairMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkCheckPermissionPairMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkCheckPermissionPairMultiError) AllErrors() []error { return m }

// BulkCheckPermissionPairValidationError is the validation error returned by
// BulkCheckPermissionPair.Validate if the designated constraints aren't met.
type BulkCheckPermissionPairValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkCheckPermissionPairValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkCheckPermissionPairValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkCheckPermissionPairValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkCheckPermissionPairValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkCheckPermissionPairValidationError) ErrorName() string {
	return "BulkCheckPermissionPairValidationError"
}

// Error satisfies the builtin error interface
func (e BulkCheckPermissionPairValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkCheckPermissionPair.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkCheckPermissionPairValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkCheckPermissionPairValidationError{}

// Validate checks the field values on BulkCheckPermissionResponseItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkCheckPermissionResponseItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkCheckPermissionResponseItem with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkCheckPermissionResponseItemMultiError, or nil if none found.
func (m *BulkCheckPermissionResponseItem) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkCheckPermissionResponseItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _BulkCheckPermissionResponseItem_Permissionship_NotInLookup[m.GetPermissionship()]; ok {
		err := BulkCheckPermissionResponseItemValidationError{
			field:  "Permissionship",
			reason: "value must not be in list [PERMISSIONSHIP_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := CheckPermissionResponse_Permissionship_name[int32(m.GetPermissionship())]; !ok {
		err := BulkCheckPermissionResponseItemValidationError{
			field:  "Permissionship",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPartialCaveatInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkCheckPermissionResponseItemValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkCheckPermissionResponseItemValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPartialCaveatInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkCheckPermissionResponseItemValidationError{
				field:  "PartialCaveatInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BulkCheckPermissionResponseItemMultiError(errors)
	}

	return nil
}

// BulkCheckPermissionResponseItemMultiError is an error wrapping multiple
// validation errors returned by BulkCheckPermissionResponseItem.ValidateAll()
// if the designated constraints aren't met.
type BulkCheckPermissionResponseItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkCheckPermissionResponseItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkCheckPermissionResponseItemMultiError) AllErrors() []error { return m }

// BulkCheckPermissionResponseItemValidationError is the validation error
// returned by BulkCheckPermissionResponseItem.Validate if the designated
// constraints aren't met.
type BulkCheckPermissionResponseItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkCheckPermissionResponseItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkCheckPermissionResponseItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkCheckPermissionResponseItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkCheckPermissionResponseItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkCheckPermissionResponseItemValidationError) ErrorName() string {
	return "BulkCheckPermissionResponseItemValidationError"
}

// Error satisfies the builtin error interface
func (e BulkCheckPermissionResponseItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkCheckPermissionResponseItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkCheckPermissionResponseItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkCheckPermissionResponseItemValidationError{}

var _BulkCheckPermissionResponseItem_Permissionship_NotInLookup = map[CheckPermissionResponse_Permissionship]struct{}{
	0: {},
}

// Validate checks the field values on BulkImportRelationshipsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkImportRelationshipsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkImportRelationshipsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkImportRelationshipsRequestMultiError, or nil if none found.
func (m *BulkImportRelationshipsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkImportRelationshipsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRelationships() {
		_, _ = idx, item

		if item == nil {
			err := BulkImportRelationshipsRequestValidationError{
				field:  fmt.Sprintf("Relationships[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkImportRelationshipsRequestValidationError{
						field:  fmt.Sprintf("Relationships[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkImportRelationshipsRequestValidationError{
						field:  fmt.Sprintf("Relationships[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkImportRelationshipsRequestValidationError{
					field:  fmt.Sprintf("Relationships[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptionalTransactionMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkImportRelationshipsRequestValidationError{
					field:  "OptionalTransactionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkImportRelationshipsRequestValidationError{
					field:  "OptionalTransactionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalTransactionMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkImportRelationshipsRequestValidationError{
				field:  "OptionalTransactionMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BulkImportRelationshipsRequestMultiError(errors)
	}

	return nil
}

// BulkImportRelationshipsRequestMultiError is an error wrapping multiple
// validation errors returned by BulkImportRelationshipsRequest.ValidateAll()
// if the designated constraints aren't met.
type BulkImportRelationshipsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkImportRelationshipsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkImportRelationshipsRequestMultiError) AllErrors() []error { return m }

// BulkImportRelationshipsRequestValidationError is the validation error
// returned by BulkImportRelationshipsRequest.Validate if the designated
// constraints aren't met.
type BulkImportRelationshipsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkImportRelationshipsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkImportRelationshipsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkImportRelationshipsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkImportRelationshipsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkImportRelationshipsRequestValidationError) ErrorName() string {
	return "BulkImportRelationshipsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BulkImportRelationshipsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkImportRelationshipsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkImportRelationshipsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkImportRelationshipsRequestValidationError{}

// Validate checks the field values on BulkImportRelationshipsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkImportRelationshipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkImportRelationshipsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkImportRelationshipsResponseMultiError, or nil if none found.
func (m *BulkImportRelationshipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkImportRelationshipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NumLoaded

	if len(errors) > 0 {
		return BulkImportRelationshipsResponseMultiError(errors)
	}

	return nil
}

// BulkImportRelationshipsResponseMultiError is an error wrapping multiple
// validation errors returned by BulkImportRelationshipsResponse.ValidateAll()
// if the designated constraints aren't met.
type BulkImportRelationshipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkImportRelationshipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkImportRelationshipsResponseMultiError) AllErrors() []error { return m }

// BulkImportRelationshipsResponseValidationError is the validation error
// returned by BulkImportRelationshipsResponse.Validate if the designated
// constraints aren't met.
type BulkImportRelationshipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkImportRelationshipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkImportRelationshipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkImportRelationshipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkImportRelationshipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkImportRelationshipsResponseValidationError) ErrorName() string {
	return "BulkImportRelationshipsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BulkImportRelationshipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkImportRelationshipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkImportRelationshipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkImportRelationshipsResponseValidationError{}

// Validate checks the field values on BulkExportRelationshipsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkExportRelationshipsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkExportRelationshipsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkExportRelationshipsRequestMultiError, or nil if none found.
func (m *BulkExportRelationshipsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkExportRelationshipsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkExportRelationshipsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkExportRelationshipsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkExportRelationshipsRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOptionalLimit() < 0 {
		err := BulkExportRelationshipsRequestValidationError{
			field:  "OptionalLimit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOptionalCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkExportRelationshipsRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkExportRelationshipsRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkExportRelationshipsRequestValidationError{
				field:  "OptionalCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOptionalRelationshipFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkExportRelationshipsRequestValidationError{
					field:  "OptionalRelationshipFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkExportRelationshipsRequestValidationError{
					field:  "OptionalRelationshipFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalRelationshipFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkExportRelationshipsRequestValidationError{
				field:  "OptionalRelationshipFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BulkExportRelationshipsRequestMultiError(errors)
	}

	return nil
}

// BulkExportRelationshipsRequestMultiError is an error wrapping multiple
// validation errors returned by BulkExportRelationshipsRequest.ValidateAll()
// if the designated constraints aren't met.
type BulkExportRelationshipsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkExportRelationshipsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkExportRelationshipsRequestMultiError) AllErrors() []error { return m }

// BulkExportRelationshipsRequestValidationError is the validation error
// returned by BulkExportRelationshipsRequest.Validate if the designated
// constraints aren't met.
type BulkExportRelationshipsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkExportRelationshipsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkExportRelationshipsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkExportRelationshipsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkExportRelationshipsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkExportRelationshipsRequestValidationError) ErrorName() string {
	return "BulkExportRelationshipsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BulkExportRelationshipsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkExportRelationshipsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkExportRelationshipsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkExportRelationshipsRequestValidationError{}

// Validate checks the field values on BulkExportRelationshipsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkExportRelationshipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkExportRelationshipsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkExportRelationshipsResponseMultiError, or nil if none found.
func (m *BulkExportRelationshipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkExportRelationshipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAfterResultCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BulkExportRelationshipsResponseValidationError{
					field:  "AfterResultCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BulkExportRelationshipsResponseValidationError{
					field:  "AfterResultCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfterResultCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BulkExportRelationshipsResponseValidationError{
				field:  "AfterResultCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRelationships() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkExportRelationshipsResponseValidationError{
						field:  fmt.Sprintf("Relationships[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkExportRelationshipsResponseValidationError{
						field:  fmt.Sprintf("Relationships[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkExportRelationshipsResponseValidationError{
					field:  fmt.Sprintf("Relationships[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkExportRelationshipsResponseMultiError(errors)
	}

	return nil
}

// BulkExportRelationshipsResponseMultiError is an error wrapping multiple
// validation errors returned by BulkExportRelationshipsResponse.ValidateAll()
// if the designated constraints aren't met.
type BulkExportRelationshipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkExportRelationshipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkExportRelationshipsResponseMultiError) AllErrors() []error { return m }

// BulkExportRelationshipsResponseValidationError is the validation error
// returned by BulkExportRelationshipsResponse.Validate if the designated
// constraints aren't met.
type BulkExportRelationshipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkExportRelationshipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkExportRelationshipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkExportRelationshipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkExportRelationshipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkExportRelationshipsResponseValidationError) ErrorName() string {
	return "BulkExportRelationshipsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BulkExportRelationshipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkExportRelationshipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkExportRelationshipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkExportRelationshipsResponseValidationError{}

// Validate checks the field values on ExperimentalReflectSchemaRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExperimentalReflectSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExperimentalReflectSchemaRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExperimentalReflectSchemaRequestMultiError, or nil if none found.
func (m *ExperimentalReflectSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalReflectSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalReflectSchemaRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalReflectSchemaRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalReflectSchemaRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOptionalFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExperimentalReflectSchemaRequestValidationError{
						field:  fmt.Sprintf("OptionalFilters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExperimentalReflectSchemaRequestValidationError{
						field:  fmt.Sprintf("OptionalFilters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExperimentalReflectSchemaRequestValidationError{
					field:  fmt.Sprintf("OptionalFilters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExperimentalReflectSchemaRequestMultiError(errors)
	}

	return nil
}

// ExperimentalReflectSchemaRequestMultiError is an error wrapping multiple
// validation errors returned by
// ExperimentalReflectSchemaRequest.ValidateAll() if the designated
// constraints aren't met.
type ExperimentalReflectSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalReflectSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalReflectSchemaRequestMultiError) AllErrors() []error { return m }

// ExperimentalReflectSchemaRequestValidationError is the validation error
// returned by ExperimentalReflectSchemaRequest.Validate if the designated
// constraints aren't met.
type ExperimentalReflectSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalReflectSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalReflectSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalReflectSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalReflectSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalReflectSchemaRequestValidationError) ErrorName() string {
	return "ExperimentalReflectSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalReflectSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalReflectSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalReflectSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalReflectSchemaRequestValidationError{}

// Validate checks the field values on ExperimentalReflectSchemaResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExperimentalReflectSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExperimentalReflectSchemaResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExperimentalReflectSchemaResponseMultiError, or nil if none found.
func (m *ExperimentalReflectSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalReflectSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDefinitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExperimentalReflectSchemaResponseValidationError{
						field:  fmt.Sprintf("Definitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExperimentalReflectSchemaResponseValidationError{
						field:  fmt.Sprintf("Definitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExperimentalReflectSchemaResponseValidationError{
					field:  fmt.Sprintf("Definitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCaveats() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExperimentalReflectSchemaResponseValidationError{
						field:  fmt.Sprintf("Caveats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExperimentalReflectSchemaResponseValidationError{
						field:  fmt.Sprintf("Caveats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExperimentalReflectSchemaResponseValidationError{
					field:  fmt.Sprintf("Caveats[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalReflectSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalReflectSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalReflectSchemaResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExperimentalReflectSchemaResponseMultiError(errors)
	}

	return nil
}

// ExperimentalReflectSchemaResponseMultiError is an error wrapping multiple
// validation errors returned by
// ExperimentalReflectSchemaResponse.ValidateAll() if the designated
// constraints aren't met.
type ExperimentalReflectSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalReflectSchemaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalReflectSchemaResponseMultiError) AllErrors() []error { return m }

// ExperimentalReflectSchemaResponseValidationError is the validation error
// returned by ExperimentalReflectSchemaResponse.Validate if the designated
// constraints aren't met.
type ExperimentalReflectSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalReflectSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalReflectSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalReflectSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalReflectSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalReflectSchemaResponseValidationError) ErrorName() string {
	return "ExperimentalReflectSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalReflectSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalReflectSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalReflectSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalReflectSchemaResponseValidationError{}

// Validate checks the field values on ExpSchemaFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExpSchemaFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpSchemaFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpSchemaFilterMultiError, or nil if none found.
func (m *ExpSchemaFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpSchemaFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptionalDefinitionNameFilter

	// no validation rules for OptionalCaveatNameFilter

	// no validation rules for OptionalRelationNameFilter

	// no validation rules for OptionalPermissionNameFilter

	if len(errors) > 0 {
		return ExpSchemaFilterMultiError(errors)
	}

	return nil
}

// ExpSchemaFilterMultiError is an error wrapping multiple validation errors
// returned by ExpSchemaFilter.ValidateAll() if the designated constraints
// aren't met.
type ExpSchemaFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpSchemaFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpSchemaFilterMultiError) AllErrors() []error { return m }

// ExpSchemaFilterValidationError is the validation error returned by
// ExpSchemaFilter.Validate if the designated constraints aren't met.
type ExpSchemaFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpSchemaFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpSchemaFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpSchemaFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpSchemaFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpSchemaFilterValidationError) ErrorName() string { return "ExpSchemaFilterValidationError" }

// Error satisfies the builtin error interface
func (e ExpSchemaFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpSchemaFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpSchemaFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpSchemaFilterValidationError{}

// Validate checks the field values on ExpDefinition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpDefinition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpDefinitionMultiError, or
// nil if none found.
func (m *ExpDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Comment

	for idx, item := range m.GetRelations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpDefinitionValidationError{
						field:  fmt.Sprintf("Relations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpDefinitionValidationError{
						field:  fmt.Sprintf("Relations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpDefinitionValidationError{
					field:  fmt.Sprintf("Relations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPermissions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpDefinitionValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpDefinitionValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpDefinitionValidationError{
					field:  fmt.Sprintf("Permissions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExpDefinitionMultiError(errors)
	}

	return nil
}

// ExpDefinitionMultiError is an error wrapping multiple validation errors
// returned by ExpDefinition.ValidateAll() if the designated constraints
// aren't met.
type ExpDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpDefinitionMultiError) AllErrors() []error { return m }

// ExpDefinitionValidationError is the validation error returned by
// ExpDefinition.Validate if the designated constraints aren't met.
type ExpDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpDefinitionValidationError) ErrorName() string { return "ExpDefinitionValidationError" }

// Error satisfies the builtin error interface
func (e ExpDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpDefinitionValidationError{}

// Validate checks the field values on ExpCaveat with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpCaveat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpCaveat with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpCaveatMultiError, or nil
// if none found.
func (m *ExpCaveat) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpCaveat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Comment

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpCaveatValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpCaveatValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpCaveatValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Expression

	if len(errors) > 0 {
		return ExpCaveatMultiError(errors)
	}

	return nil
}

// ExpCaveatMultiError is an error wrapping multiple validation errors returned
// by ExpCaveat.ValidateAll() if the designated constraints aren't met.
type ExpCaveatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpCaveatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpCaveatMultiError) AllErrors() []error { return m }

// ExpCaveatValidationError is the validation error returned by
// ExpCaveat.Validate if the designated constraints aren't met.
type ExpCaveatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpCaveatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpCaveatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpCaveatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpCaveatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpCaveatValidationError) ErrorName() string { return "ExpCaveatValidationError" }

// Error satisfies the builtin error interface
func (e ExpCaveatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpCaveat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpCaveatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpCaveatValidationError{}

// Validate checks the field values on ExpCaveatParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpCaveatParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpCaveatParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpCaveatParameterMultiError, or nil if none found.
func (m *ExpCaveatParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpCaveatParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for ParentCaveatName

	if len(errors) > 0 {
		return ExpCaveatParameterMultiError(errors)
	}

	return nil
}

// ExpCaveatParameterMultiError is an error wrapping multiple validation errors
// returned by ExpCaveatParameter.ValidateAll() if the designated constraints
// aren't met.
type ExpCaveatParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpCaveatParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpCaveatParameterMultiError) AllErrors() []error { return m }

// ExpCaveatParameterValidationError is the validation error returned by
// ExpCaveatParameter.Validate if the designated constraints aren't met.
type ExpCaveatParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpCaveatParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpCaveatParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpCaveatParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpCaveatParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpCaveatParameterValidationError) ErrorName() string {
	return "ExpCaveatParameterValidationError"
}

// Error satisfies the builtin error interface
func (e ExpCaveatParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpCaveatParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpCaveatParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpCaveatParameterValidationError{}

// Validate checks the field values on ExpRelation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpRelation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpRelation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpRelationMultiError, or
// nil if none found.
func (m *ExpRelation) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpRelation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Comment

	// no validation rules for ParentDefinitionName

	for idx, item := range m.GetSubjectTypes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpRelationValidationError{
						field:  fmt.Sprintf("SubjectTypes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpRelationValidationError{
						field:  fmt.Sprintf("SubjectTypes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpRelationValidationError{
					field:  fmt.Sprintf("SubjectTypes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExpRelationMultiError(errors)
	}

	return nil
}

// ExpRelationMultiError is an error wrapping multiple validation errors
// returned by ExpRelation.ValidateAll() if the designated constraints aren't met.
type ExpRelationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpRelationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpRelationMultiError) AllErrors() []error { return m }

// ExpRelationValidationError is the validation error returned by
// ExpRelation.Validate if the designated constraints aren't met.
type ExpRelationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpRelationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpRelationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpRelationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpRelationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpRelationValidationError) ErrorName() string { return "ExpRelationValidationError" }

// Error satisfies the builtin error interface
func (e ExpRelationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpRelation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpRelationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpRelationValidationError{}

// Validate checks the field values on ExpTypeReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExpTypeReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpTypeReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpTypeReferenceMultiError, or nil if none found.
func (m *ExpTypeReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpTypeReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectDefinitionName

	// no validation rules for OptionalCaveatName

	switch v := m.Typeref.(type) {
	case *ExpTypeReference_IsTerminalSubject:
		if v == nil {
			err := ExpTypeReferenceValidationError{
				field:  "Typeref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for IsTerminalSubject
	case *ExpTypeReference_OptionalRelationName:
		if v == nil {
			err := ExpTypeReferenceValidationError{
				field:  "Typeref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for OptionalRelationName
	case *ExpTypeReference_IsPublicWildcard:
		if v == nil {
			err := ExpTypeReferenceValidationError{
				field:  "Typeref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for IsPublicWildcard
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExpTypeReferenceMultiError(errors)
	}

	return nil
}

// ExpTypeReferenceMultiError is an error wrapping multiple validation errors
// returned by ExpTypeReference.ValidateAll() if the designated constraints
// aren't met.
type ExpTypeReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpTypeReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpTypeReferenceMultiError) AllErrors() []error { return m }

// ExpTypeReferenceValidationError is the validation error returned by
// ExpTypeReference.Validate if the designated constraints aren't met.
type ExpTypeReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpTypeReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpTypeReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpTypeReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpTypeReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpTypeReferenceValidationError) ErrorName() string { return "ExpTypeReferenceValidationError" }

// Error satisfies the builtin error interface
func (e ExpTypeReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpTypeReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpTypeReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpTypeReferenceValidationError{}

// Validate checks the field values on ExpPermission with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpPermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpPermissionMultiError, or
// nil if none found.
func (m *ExpPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Comment

	// no validation rules for ParentDefinitionName

	if len(errors) > 0 {
		return ExpPermissionMultiError(errors)
	}

	return nil
}

// ExpPermissionMultiError is an error wrapping multiple validation errors
// returned by ExpPermission.ValidateAll() if the designated constraints
// aren't met.
type ExpPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpPermissionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpPermissionMultiError) AllErrors() []error { return m }

// ExpPermissionValidationError is the validation error returned by
// ExpPermission.Validate if the designated constraints aren't met.
type ExpPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpPermissionValidationError) ErrorName() string { return "ExpPermissionValidationError" }

// Error satisfies the builtin error interface
func (e ExpPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpPermissionValidationError{}

// Validate checks the field values on ExperimentalComputablePermissionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExperimentalComputablePermissionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExperimentalComputablePermissionsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ExperimentalComputablePermissionsRequestMultiError, or nil if none found.
func (m *ExperimentalComputablePermissionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalComputablePermissionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalComputablePermissionsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalComputablePermissionsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalComputablePermissionsRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DefinitionName

	// no validation rules for RelationName

	// no validation rules for OptionalDefinitionNameFilter

	if len(errors) > 0 {
		return ExperimentalComputablePermissionsRequestMultiError(errors)
	}

	return nil
}

// ExperimentalComputablePermissionsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ExperimentalComputablePermissionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ExperimentalComputablePermissionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalComputablePermissionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalComputablePermissionsRequestMultiError) AllErrors() []error { return m }

// ExperimentalComputablePermissionsRequestValidationError is the validation
// error returned by ExperimentalComputablePermissionsRequest.Validate if the
// designated constraints aren't met.
type ExperimentalComputablePermissionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalComputablePermissionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalComputablePermissionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalComputablePermissionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalComputablePermissionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalComputablePermissionsRequestValidationError) ErrorName() string {
	return "ExperimentalComputablePermissionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalComputablePermissionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalComputablePermissionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalComputablePermissionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalComputablePermissionsRequestValidationError{}

// Validate checks the field values on ExpRelationReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpRelationReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpRelationReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpRelationReferenceMultiError, or nil if none found.
func (m *ExpRelationReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpRelationReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DefinitionName

	// no validation rules for RelationName

	// no validation rules for IsPermission

	if len(errors) > 0 {
		return ExpRelationReferenceMultiError(errors)
	}

	return nil
}

// ExpRelationReferenceMultiError is an error wrapping multiple validation
// errors returned by ExpRelationReference.ValidateAll() if the designated
// constraints aren't met.
type ExpRelationReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpRelationReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpRelationReferenceMultiError) AllErrors() []error { return m }

// ExpRelationReferenceValidationError is the validation error returned by
// ExpRelationReference.Validate if the designated constraints aren't met.
type ExpRelationReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpRelationReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpRelationReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpRelationReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpRelationReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpRelationReferenceValidationError) ErrorName() string {
	return "ExpRelationReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ExpRelationReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpRelationReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpRelationReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpRelationReferenceValidationError{}

// Validate checks the field values on
// ExperimentalComputablePermissionsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExperimentalComputablePermissionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExperimentalComputablePermissionsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ExperimentalComputablePermissionsResponseMultiError, or nil if none found.
func (m *ExperimentalComputablePermissionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalComputablePermissionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPermissions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExperimentalComputablePermissionsResponseValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExperimentalComputablePermissionsResponseValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExperimentalComputablePermissionsResponseValidationError{
					field:  fmt.Sprintf("Permissions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalComputablePermissionsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalComputablePermissionsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalComputablePermissionsResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExperimentalComputablePermissionsResponseMultiError(errors)
	}

	return nil
}

// ExperimentalComputablePermissionsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ExperimentalComputablePermissionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ExperimentalComputablePermissionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalComputablePermissionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalComputablePermissionsResponseMultiError) AllErrors() []error { return m }

// ExperimentalComputablePermissionsResponseValidationError is the validation
// error returned by ExperimentalComputablePermissionsResponse.Validate if the
// designated constraints aren't met.
type ExperimentalComputablePermissionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalComputablePermissionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalComputablePermissionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalComputablePermissionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalComputablePermissionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalComputablePermissionsResponseValidationError) ErrorName() string {
	return "ExperimentalComputablePermissionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalComputablePermissionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalComputablePermissionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalComputablePermissionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalComputablePermissionsResponseValidationError{}

// Validate checks the field values on ExperimentalDependentRelationsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExperimentalDependentRelationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExperimentalDependentRelationsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExperimentalDependentRelationsRequestMultiError, or nil if none found.
func (m *ExperimentalDependentRelationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalDependentRelationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalDependentRelationsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalDependentRelationsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalDependentRelationsRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DefinitionName

	// no validation rules for PermissionName

	if len(errors) > 0 {
		return ExperimentalDependentRelationsRequestMultiError(errors)
	}

	return nil
}

// ExperimentalDependentRelationsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ExperimentalDependentRelationsRequest.ValidateAll() if the designated
// constraints aren't met.
type ExperimentalDependentRelationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalDependentRelationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalDependentRelationsRequestMultiError) AllErrors() []error { return m }

// ExperimentalDependentRelationsRequestValidationError is the validation error
// returned by ExperimentalDependentRelationsRequest.Validate if the
// designated constraints aren't met.
type ExperimentalDependentRelationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalDependentRelationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalDependentRelationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalDependentRelationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalDependentRelationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalDependentRelationsRequestValidationError) ErrorName() string {
	return "ExperimentalDependentRelationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalDependentRelationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalDependentRelationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalDependentRelationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalDependentRelationsRequestValidationError{}

// Validate checks the field values on ExperimentalDependentRelationsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExperimentalDependentRelationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExperimentalDependentRelationsResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ExperimentalDependentRelationsResponseMultiError, or nil if none found.
func (m *ExperimentalDependentRelationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalDependentRelationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRelations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExperimentalDependentRelationsResponseValidationError{
						field:  fmt.Sprintf("Relations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExperimentalDependentRelationsResponseValidationError{
						field:  fmt.Sprintf("Relations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExperimentalDependentRelationsResponseValidationError{
					field:  fmt.Sprintf("Relations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalDependentRelationsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalDependentRelationsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalDependentRelationsResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExperimentalDependentRelationsResponseMultiError(errors)
	}

	return nil
}

// ExperimentalDependentRelationsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ExperimentalDependentRelationsResponse.ValidateAll() if the designated
// constraints aren't met.
type ExperimentalDependentRelationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalDependentRelationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalDependentRelationsResponseMultiError) AllErrors() []error { return m }

// ExperimentalDependentRelationsResponseValidationError is the validation
// error returned by ExperimentalDependentRelationsResponse.Validate if the
// designated constraints aren't met.
type ExperimentalDependentRelationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalDependentRelationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalDependentRelationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalDependentRelationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalDependentRelationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalDependentRelationsResponseValidationError) ErrorName() string {
	return "ExperimentalDependentRelationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalDependentRelationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalDependentRelationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalDependentRelationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalDependentRelationsResponseValidationError{}

// Validate checks the field values on ExperimentalDiffSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExperimentalDiffSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExperimentalDiffSchemaRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExperimentalDiffSchemaRequestMultiError, or nil if none found.
func (m *ExperimentalDiffSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalDiffSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalDiffSchemaRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalDiffSchemaRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalDiffSchemaRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ComparisonSchema

	if len(errors) > 0 {
		return ExperimentalDiffSchemaRequestMultiError(errors)
	}

	return nil
}

// ExperimentalDiffSchemaRequestMultiError is an error wrapping multiple
// validation errors returned by ExperimentalDiffSchemaRequest.ValidateAll()
// if the designated constraints aren't met.
type ExperimentalDiffSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalDiffSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalDiffSchemaRequestMultiError) AllErrors() []error { return m }

// ExperimentalDiffSchemaRequestValidationError is the validation error
// returned by ExperimentalDiffSchemaRequest.Validate if the designated
// constraints aren't met.
type ExperimentalDiffSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalDiffSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalDiffSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalDiffSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalDiffSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalDiffSchemaRequestValidationError) ErrorName() string {
	return "ExperimentalDiffSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalDiffSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalDiffSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalDiffSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalDiffSchemaRequestValidationError{}

// Validate checks the field values on ExperimentalDiffSchemaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExperimentalDiffSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExperimentalDiffSchemaResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExperimentalDiffSchemaResponseMultiError, or nil if none found.
func (m *ExperimentalDiffSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExperimentalDiffSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDiffs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExperimentalDiffSchemaResponseValidationError{
						field:  fmt.Sprintf("Diffs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExperimentalDiffSchemaResponseValidationError{
						field:  fmt.Sprintf("Diffs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExperimentalDiffSchemaResponseValidationError{
					field:  fmt.Sprintf("Diffs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExperimentalDiffSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExperimentalDiffSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExperimentalDiffSchemaResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExperimentalDiffSchemaResponseMultiError(errors)
	}

	return nil
}

// ExperimentalDiffSchemaResponseMultiError is an error wrapping multiple
// validation errors returned by ExperimentalDiffSchemaResponse.ValidateAll()
// if the designated constraints aren't met.
type ExperimentalDiffSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExperimentalDiffSchemaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExperimentalDiffSchemaResponseMultiError) AllErrors() []error { return m }

// ExperimentalDiffSchemaResponseValidationError is the validation error
// returned by ExperimentalDiffSchemaResponse.Validate if the designated
// constraints aren't met.
type ExperimentalDiffSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExperimentalDiffSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExperimentalDiffSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExperimentalDiffSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExperimentalDiffSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExperimentalDiffSchemaResponseValidationError) ErrorName() string {
	return "ExperimentalDiffSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExperimentalDiffSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExperimentalDiffSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExperimentalDiffSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExperimentalDiffSchemaResponseValidationError{}

// Validate checks the field values on ExpRelationSubjectTypeChange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpRelationSubjectTypeChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpRelationSubjectTypeChange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpRelationSubjectTypeChangeMultiError, or nil if none found.
func (m *ExpRelationSubjectTypeChange) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpRelationSubjectTypeChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpRelationSubjectTypeChangeValidationError{
					field:  "Relation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpRelationSubjectTypeChangeValidationError{
					field:  "Relation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpRelationSubjectTypeChangeValidationError{
				field:  "Relation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetChangedSubjectType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpRelationSubjectTypeChangeValidationError{
					field:  "ChangedSubjectType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpRelationSubjectTypeChangeValidationError{
					field:  "ChangedSubjectType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChangedSubjectType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpRelationSubjectTypeChangeValidationError{
				field:  "ChangedSubjectType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExpRelationSubjectTypeChangeMultiError(errors)
	}

	return nil
}

// ExpRelationSubjectTypeChangeMultiError is an error wrapping multiple
// validation errors returned by ExpRelationSubjectTypeChange.ValidateAll() if
// the designated constraints aren't met.
type ExpRelationSubjectTypeChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpRelationSubjectTypeChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpRelationSubjectTypeChangeMultiError) AllErrors() []error { return m }

// ExpRelationSubjectTypeChangeValidationError is the validation error returned
// by ExpRelationSubjectTypeChange.Validate if the designated constraints
// aren't met.
type ExpRelationSubjectTypeChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpRelationSubjectTypeChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpRelationSubjectTypeChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpRelationSubjectTypeChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpRelationSubjectTypeChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpRelationSubjectTypeChangeValidationError) ErrorName() string {
	return "ExpRelationSubjectTypeChangeValidationError"
}

// Error satisfies the builtin error interface
func (e ExpRelationSubjectTypeChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpRelationSubjectTypeChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpRelationSubjectTypeChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpRelationSubjectTypeChangeValidationError{}

// Validate checks the field values on ExpCaveatParameterTypeChange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpCaveatParameterTypeChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpCaveatParameterTypeChange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpCaveatParameterTypeChangeMultiError, or nil if none found.
func (m *ExpCaveatParameterTypeChange) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpCaveatParameterTypeChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetParameter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpCaveatParameterTypeChangeValidationError{
					field:  "Parameter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpCaveatParameterTypeChangeValidationError{
					field:  "Parameter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpCaveatParameterTypeChangeValidationError{
				field:  "Parameter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PreviousType

	if len(errors) > 0 {
		return ExpCaveatParameterTypeChangeMultiError(errors)
	}

	return nil
}

// ExpCaveatParameterTypeChangeMultiError is an error wrapping multiple
// validation errors returned by ExpCaveatParameterTypeChange.ValidateAll() if
// the designated constraints aren't met.
type ExpCaveatParameterTypeChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpCaveatParameterTypeChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpCaveatParameterTypeChangeMultiError) AllErrors() []error { return m }

// ExpCaveatParameterTypeChangeValidationError is the validation error returned
// by ExpCaveatParameterTypeChange.Validate if the designated constraints
// aren't met.
type ExpCaveatParameterTypeChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpCaveatParameterTypeChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpCaveatParameterTypeChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpCaveatParameterTypeChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpCaveatParameterTypeChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpCaveatParameterTypeChangeValidationError) ErrorName() string {
	return "ExpCaveatParameterTypeChangeValidationError"
}

// Error satisfies the builtin error interface
func (e ExpCaveatParameterTypeChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpCaveatParameterTypeChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpCaveatParameterTypeChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpCaveatParameterTypeChangeValidationError{}

// Validate checks the field values on ExpSchemaDiff with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpSchemaDiff) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpSchemaDiff with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpSchemaDiffMultiError, or
// nil if none found.
func (m *ExpSchemaDiff) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpSchemaDiff) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Diff.(type) {
	case *ExpSchemaDiff_DefinitionAdded:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDefinitionAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "DefinitionAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "DefinitionAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefinitionAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "DefinitionAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_DefinitionRemoved:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDefinitionRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "DefinitionRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "DefinitionRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefinitionRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "DefinitionRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_DefinitionDocCommentChanged:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDefinitionDocCommentChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "DefinitionDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "DefinitionDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefinitionDocCommentChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "DefinitionDocCommentChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_RelationAdded:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "RelationAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_RelationRemoved:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "RelationRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_RelationDocCommentChanged:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationDocCommentChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationDocCommentChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "RelationDocCommentChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_RelationSubjectTypeAdded:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationSubjectTypeAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationSubjectTypeAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationSubjectTypeAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationSubjectTypeAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "RelationSubjectTypeAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_RelationSubjectTypeRemoved:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationSubjectTypeRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationSubjectTypeRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "RelationSubjectTypeRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationSubjectTypeRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "RelationSubjectTypeRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_PermissionAdded:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "PermissionAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "PermissionAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "PermissionAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_PermissionRemoved:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "PermissionRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "PermissionRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "PermissionRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_PermissionDocCommentChanged:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionDocCommentChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "PermissionDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "PermissionDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionDocCommentChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "PermissionDocCommentChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_PermissionExprChanged:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionExprChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "PermissionExprChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "PermissionExprChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionExprChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "PermissionExprChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_CaveatAdded:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "CaveatAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_CaveatRemoved:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "CaveatRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_CaveatDocCommentChanged:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatDocCommentChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatDocCommentChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "CaveatDocCommentChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_CaveatExprChanged:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatExprChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatExprChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatExprChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatExprChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "CaveatExprChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_CaveatParameterAdded:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatParameterAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatParameterAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatParameterAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatParameterAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "CaveatParameterAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_CaveatParameterRemoved:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatParameterRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatParameterRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatParameterRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatParameterRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "CaveatParameterRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpSchemaDiff_CaveatParameterTypeChanged:
		if v == nil {
			err := ExpSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatParameterTypeChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatParameterTypeChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpSchemaDiffValidationError{
						field:  "CaveatParameterTypeChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatParameterTypeChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpSchemaDiffValidationError{
					field:  "CaveatParameterTypeChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExpSchemaDiffMultiError(errors)
	}

	return nil
}

// ExpSchemaDiffMultiError is an error wrapping multiple validation errors
// returned by ExpSchemaDiff.ValidateAll() if the designated constraints
// aren't met.
type ExpSchemaDiffMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpSchemaDiffMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpSchemaDiffMultiError) AllErrors() []error { return m }

// ExpSchemaDiffValidationError is the validation error returned by
// ExpSchemaDiff.Validate if the designated constraints aren't met.
type ExpSchemaDiffValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpSchemaDiffValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpSchemaDiffValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpSchemaDiffValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpSchemaDiffValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpSchemaDiffValidationError) ErrorName() string { return "ExpSchemaDiffValidationError" }

// Error satisfies the builtin error interface
func (e ExpSchemaDiffValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpSchemaDiff.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpSchemaDiffValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpSchemaDiffValidationError{}
